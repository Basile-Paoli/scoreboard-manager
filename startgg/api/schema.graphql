"""
Specify a query to be read from gql-public. Will use the configured cacheAge on
the query resolve configuration, or the override value passed through the
directive as publicCache(cacheAge: INT) argument.
"""
directive @publicCache(
    """Optional override for the query-level cacheAge value, in seconds."""
    cacheAge: Int
) on FIELD

"""
Specify a field to only be included in the response if the user is logged in.
"""
directive @userData on FIELD

"""A restricted action definition"""
type Action {
    isAllowed: Boolean
    limit: Int
    name: String
}

"""A set of actions available for an entity to take"""
interface ActionSet {
    id: ID
    actions(isAllowed: Boolean): [Action]
}

"""A summary of an action taken by an entity"""
type ActionSummary {
    allowedAt: Timestamp
    allowedUntil: Timestamp
    isAllowed: Boolean
    limit: Int
    name: String
    used: Int
}

"""A window of time that an ActionSet can be taken"""
type ActionWindow {
    id: ID
    actionSet: ActionSet
    endAt: Timestamp
    startAt: Timestamp
    state: ActionWindowState
}

"""A state representing whether actions can currently be made"""
enum ActionWindowState {
    UPCOMING
    OPEN
    CLOSED
}

"""Represents the state of an activity"""
enum ActivityState {
    """Activity is created"""
    CREATED

    """Activity is active or in progress"""
    ACTIVE

    """Activity is done"""
    COMPLETED

    """Activity is ready to be started"""
    READY

    """Activity is invalid"""
    INVALID

    """Activity, like a set, has been called to start"""
    CALLED

    """Activity is queued to run"""
    QUEUED
}

"""Describes a label and value to display along with a standing."""
type AdditionalColumn {
    """The name of the label. Will show up as a column header."""
    label: String!

    """The value to display."""
    value: String
}

"""A user's address"""
type Address {
    id: ID
    address: String
    address2: String
    city: String
    country: String
    countryId: Int
    createdAt: Timestamp
    nameFirst: String
    nameLast: String
    overrideAddress: Boolean
    phoneNumber: String
    state: String
    stateId: Int
    type: String
    updatedAt: Timestamp
    userId: Int @deprecated(reason: "use User instead")
    zipcode: String
}

type AdminActions {
    name: String
    amount: Float
    date: Int
    paidByEmail: String
}

"""An auth client"""
type AuthClient {
    id: ID
    appUrl: String
    clientSecret: String
    createdAt: Timestamp
    description: String
    name: String
    ownerId: Int
    redirect_uri: String
}

input AuthClientUpdate {
    name: String
    description: String
    redirect_uri: String
    appUrl: String
}

"""Represents the name of the third-party service (e.g Twitter) for OAuth"""
enum AuthorizationType {
    TWITTER
    TWITCH
    STEAM
    DISCORD
    XBOX
    EPIC
    BATTLENET
    MIXER
}

"""A scope that can be requested by an OAuth client/application"""
type AuthScope {
    id: ID
    description: String
    developerDescription: String
}

"""An auth token"""
type AuthToken {
    id: ID
    apiVersion: String
    clientId: Int
    createdAt: Timestamp
    description: String
    expiresAt: Timestamp
    roles: [Role]
    scopes: String
    type: Int
    user: User
}

"""
Represents what type of application is generating the token e.g. personal or third party
"""
enum AuthTokenApplicationType {
    PERSONAL
    THIRD_PARTY
}

"""Bracket-specific configuration"""
interface BracketConfig {
    id: ID
    bracketType: BracketType
}

"""The type of Bracket format that a Phase is configured with."""
enum BracketType {
    SINGLE_ELIMINATION
    DOUBLE_ELIMINATION
    ROUND_ROBIN
    SWISS
    EXHIBITION
    CUSTOM_SCHEDULE
    MATCHMAKING
    ELIMINATION_ROUNDS
    RACE
    CIRCUIT
}

"""Cards for a deck of a participant/entrant"""
type Card {
    id: ID

    """The character id associated with this card."""
    characterId: Int

    """The description of the card."""
    description: String

    """External ID from external source associated with this card."""
    externalId: String

    """External API from which the card is derived from."""
    externalSource: String
    images(type: String): [Image]

    """Additional card information, such as type, cost, rarity, etc."""
    metadata: JSON

    """The name of the card."""
    name: String
}

type CardConnection {
    pageInfo: PageInfo
    nodes: [Card]
}

input CardPageFilter {
    id: ID
    ids: [ID]
    name: String
    externalId: [ID]
    videogameId: ID
}

input CardPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: CardPageFilter
}

"""A character in a videogame"""
type Character {
    id: ID
    images(type: String): [Image]

    """Name of Character"""
    name: String
}

"""Links an event to a circuit, and holds data about the relation"""
type CircuitEventLink {
    id: ID

    """Point mapping group"""
    pointMappingGroup: PointMappingGroup

    """Circuit Tier for this Event"""
    tier: EventTier
    unpublished: Boolean
}

"""A circuit type phase group"""
type CircuitPhaseGroup {
    id: ID

    """The bracket type of this group's phase."""
    bracketType: BracketType

    """URL for this phase groups's bracket."""
    bracketUrl: String
    checkInFinalizeAction: String
    checkInState: String

    """The sets of current round of a phase group"""
    currentRoundSets: [Set]

    """Unique identifier for this group within the context of its phase"""
    displayIdentifier: String

    """Event check in groups that the phase group is linked to"""
    eventCheckInGroup: EventCheckInGroup
    firebasePath: String

    """
    For the given phase group, this is the start time of the first round that occurs in the group.
    """
    firstRoundTime: Timestamp
    groupTypeId: Int

    """
    Matchmaking settings for this Phase Group. Should only be used in queries for
    Phase Groups that are known to be of the Matchmaking bracket type.
    """
    matchmakingSettings: JSON
    numRounds: Int

    """The number of seeds for a phase group."""
    numSeeds(checkInState: Int): Int
    oldSets(
        """Limit to Sets in the current round"""
        currentRoundOnly: Boolean = false
    ): [Set]
    paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds', which is now paginated")

    """Paginated sets on this phaseGroup"""
    paginatedSets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection @deprecated(reason: "Please use 'sets', which is now paginated")

    """Percentage of matches completed for this phase group"""
    percentComplete: Int

    """The phase associated with this phase group"""
    phase: Phase
    phaseId: Int @deprecated(reason: "Use phase")
    pointMappingGroups: [PointMappingGroup]

    """The progressions out of this phase group"""
    progressionsOut: [Progression]
    raceConfig: JSON
    roundDisplayNames: JSON @deprecated(reason: "This is the wrong API for getting round titles. We need to put more work into the phaseGroup.rounds resolver to make it useful.")
    rounds: [Round]
    seedMap: JSON

    """Paginated seeds for this phase group"""
    seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

    """Paginated sets on this phaseGroup"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection
    standingGroup: StandingGroup

    """List of StandingGroups, or Leaderboards, for this circuit"""
    standingGroups: [StandingGroup]

    """
    Paginated list of standing points attached to this circuit's default standing group
    """
    standingPoints(query: StandingPointsPaginationQuery): StandingPointsConnection

    """Paginated list of standings"""
    standings(query: StandingGroupStandingPageFilter): StandingConnection

    """
    Unix time the group is scheduled to start. This info could also be on the wave instead.
    """
    startAt: Timestamp
    state: Int

    """Paginated stations on this phaseGroup"""
    stations(query: StationFilter): StationsConnection
    tiebreakOrder: JSON
    unpaginatedSeeds: [Seed]

    """
    URL for the phase group. Optionally, build URL for resource under the phase group
    """
    url(
        """Phase group (brackets) tab to build URL for"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """
    Gets seeds in this phaseGroup for a particular user. Normally this will only
    be 0 or 1 seed. There might be weird cases where someone has more seeds
    """
    userSeeds(
        """User ID to get sets for. If null, will default to current user."""
        userId: ID
    ): [Seed]

    """The current user's tasks for this phase group"""
    userTasks: [Task]
    wave: Wave
    waveId: Int @deprecated(reason: "Use wave")
}

"""Comparison operator"""
enum Comparator {
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    EQUAL
    LESS_THAN_OR_EQUAL
    LESS_THAN
}

"""Defines everything required to show a dynamic UI element."""
type Component {
    """The name of component to render"""
    componentName: String

    """
    Prop values to pass to the dynamic component. Props structure can have many
    different fields and types so it is not strongly typed.
    """
    props: JSON
}

"""Name, address, etc"""
type ContactInfo {
    id: ID

    """Participant City Name"""
    city: String

    """Participant Country Name"""
    country: String

    """Participant Country (region) id"""
    countryId: Int
    name: String

    """First Name"""
    nameFirst: String

    """Last Name"""
    nameLast: String

    """Participant State Name"""
    state: String

    """Participant State (region) id"""
    stateId: Int

    """Zip or Postal Code"""
    zipcode: String
}

input contactInfoParams {
    nameFirst: String
    nameLast: String
    phoneNumber: String
    birthday: String
    city: String
    countryId: Int
    stateId: Int
    zipcode: String
}

input createUserRequest {
    captcha: String
    email: String!
    password: String!
    dob: String!
    tos: Boolean!
    emailOptOut: Boolean!
    guardianEmail: String
    country: Int!
    language: String
}

"""Fields used in a Request Tier's additionalCriteria field"""
type Criteria {
    """End date for tier"""
    endAt: Timestamp

    """Max entrant count of the tier"""
    entrantCountMax: Int

    """Min entrant count of the tier"""
    entrantCountMin: Int

    """Tier location filter on Latitude, Longitude, and Radius"""
    location: JSON

    """Tier location filter on City"""
    locationCity: String

    """Tier location filter on Country"""
    locationCountry: String

    """Tier location filter on State"""
    locationState: String

    """Filter on online, offline, or neither"""
    online: Boolean

    """IDs of Platform"""
    platformIds: [ID]

    """Start date for tier"""
    startAt: Timestamp

    """Tier filter on event type"""
    type: [Int]

    """List of VideoGame ids"""
    videogameId: [ID]
}

"""CSV Column Info"""
type CSVColumnInfo {
    """Column description"""
    description: String

    """Column required status"""
    isRequired: Boolean

    """Column name"""
    name: String
}

"""CSV Configuration"""
type CSVConfig {
    """CSV Column Header Info"""
    columnInfo: [CSVColumnInfo]
}

input DateRangeFilterType {
    beforeDate: Timestamp
    afterDate: Timestamp
}

"""Deck of cards for a participant/entrant"""
type Deck {
    id: ID
    cardIds: [ID]
    cards: [Card]
    characterIds: JSON
    characters: [Character]
    connectedId: Int @deprecated(reason: "We should make an event / connectedEntity resolver if we want this")
    connectedType: String @deprecated(reason: "Every single connectedType we have is event")
    createdAt: Timestamp
    entrantId: Int @deprecated(reason: "We should make an entrant resolver if we want this")
    externalLink: String
    images: [Image]

    """True if the deck has no cards."""
    isEmpty: Boolean
    isPrimary: Boolean
    name: String
    participant: Participant
    participantId: Int @deprecated(reason: "We should make a participant resolver if we want this")
    title: String
    type: DeckType
    updatedAt: Timestamp
    valid: Boolean
}

"""Conveys the way that the contents of a deck are represented"""
enum DeckType {
    """Decks are represented as a collection of cards"""
    CARD

    """Decks are represented in one or more images"""
    IMAGE

    """Decks are represented on another site and linked"""
    EXTERNAL_LINK
}

"""An email category (announcements, registration, etc.)"""
type EmailCategory {
    id: ID
    description: String
    name: String
}

"""An email type (registration, team invite, marketing, etc.)"""
type EmailType {
    id: ID
    categoryId: Int
    name: String
}

"""
A set of restrictions for an entity (i.e. team) in order to be a member of a container (i.e. event)
"""
type EntityRestriction {
    actionWindows(
        """Only return action windows in this state"""
        state: ActionWindowState
    ): [ActionWindow]
    id: ID
    container: RestrictionContainer
    description: String
    name: String
    restrictedEntityType: String
    state: Int
}

"""An entrant in an event"""
type Entrant {
    id: ID

    """An entrant's first round seed associated with their event check-in"""
    checkInSeed: Seed
    decks: [Deck]
    event: Event
    eventId: Int @deprecated(reason: "Use event instead")

    """
    expands entrant name to [entrant.participant.prefix,
    entrant.participant.gamerTag] for singles and [null, entrant.name] for
    """
    expandedName: EntrantExpandedName
    hasIncompleteDecks: Boolean

    """Entrant's seed number in the first phase of the event."""
    initialSeedNum: Int
    isDisqualified: Boolean
    lastMatches: [Set]
    lostTo: JSON

    """Gamertags of all members of entrant (only relevant for teams)"""
    memberNames: [String]

    """
    The entrant name as it appears in bracket: gamerTag of the participant or team name
    """
    name: String

    """Computed display name for Participant(s) from Network IDs"""
    networkIdDisplayName: String

    """Paginated sets for this entrant"""
    paginatedSets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection
    participants: [Participant]

    """The phase groups this entrant is in"""
    phaseGroups: [PhaseGroup]

    """Player tied to the entrant. This does not work for teams."""
    players: [Player]

    """The record of the entrant in the event"""
    record: JSON
    seed(phaseId: ID, phaseGroupId: ID): Seed
    seeds: [Seed]
    setIdentifier(phaseGroupId: ID, round: Int): String
    skill: Int
    slug: String

    """
    Standing for this entrant given an event. All entrants queried must be in the same event (for now).
    """
    standing: Standing
    stream: Streams @deprecated(reason: "DEPRECATED. Use streams instead, which supports multiple stream types and teams.")
    streams: [Streams]

    """Team linked to this entrant, if one exists"""
    team: Team

    """Url for public entrant page"""
    url: String
}

type EntrantConnection {
    pageInfo: PageInfo
    nodes: [Entrant]
}

type EntrantExpandedName {
    prefix: String
    name: String
}

input EntrantPageFilter {
    id: ID
    ids: [ID]
    name: String
    seedless: Boolean
    eventId: ID
    excludedIds: [ID]
    createdSetOnly: Boolean
    eventType: Int
    tournamentId: ID
    search: JSON
    eventIds: [ID]
}

input EntrantPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: EntrantPageFilter
}

"""An event in a tournament"""
type Event {
    id: ID

    """true if brackets are published for this event"""
    bracketsPublished: Boolean

    """Can entrants edit teams in this event"""
    canEditTeams: Boolean

    """How long before the event start will the check-in end (in seconds)"""
    checkInBuffer: Int

    """How long the event check-in will last (in seconds)"""
    checkInDuration: Int

    """Whether check-in is enabled for this event"""
    checkInEnabled: Boolean
    checkInGroupFirebasePath: String

    """Circuit event links for this event"""
    circuitEventLinks(
        """League id to filter event links on"""
        leagueId: ID
    ): [CircuitEventLink]

    """
    Rough categorization of event tier, denoting relative importance in the competitive scene
    """
    competitionTier: Int

    """When the event was created (unix timestamp)"""
    createdAt: Timestamp

    """Last date attendees are able to create teams for team events"""
    deckSubmissionDeadline: Timestamp

    """true if hasDecks and are published for this event"""
    decksPublished: Boolean

    """Maximum number of participants each Entrant can have"""
    entrantSizeMax: Int @deprecated(reason: "Migrate to teamRosterSize")

    """Minimum number of participants each Entrant can have"""
    entrantSizeMin: Int @deprecated(reason: "Migrate to teamRosterSize")

    """The entrants that belong to an event, paginated by filter criteria"""
    entrants(query: EventEntrantPageQuery): EntrantConnection

    """event check in groups linked to the event"""
    eventCheckInGroups: [EventCheckInGroup]

    """Number of event seeds that have an error"""
    eventSeedErrorCount: Int

    """Event seeds in the event"""
    eventSeeds(query: EventSeedPageQuery): EventSeedConnection
    firebasePath: String

    """When does the first round of the event start"""
    firstRoundTime: Timestamp

    """Whether the event has decks"""
    hasDecks: Boolean

    """Whether or not this event has a Race bracket."""
    hasRace: Boolean

    """Are player tasks enabled for this event"""
    hasTasks: Boolean
    images(type: String): [Image]

    """Whether or not the Event has been completed"""
    isCompleted: Boolean

    """Whether or not this is an FFA Event."""
    isFFA: Boolean

    """Whether the event is an online event or not"""
    isOnline: Boolean
    isRegistrationOpen: Boolean

    """Whether or not this event is a single bracket event."""
    isSingleBracket: Boolean

    """Indicates whether this event is a teams event."""
    isTeams: Boolean

    """Is this user registered for this event"""
    isUserRegistered(
        """
        User to get registration info for. Defaults to currently logged in user.
        """
        userId: ID
    ): Boolean
    league: League

    """Max points this event is worth for a given league"""
    leagueMaxPoints(leagueId: ID): Int @deprecated(reason: "Uses old LeagueBL::getMaxPointsByEvents function")

    """Request tier that this event is in for a given league"""
    leagueTier(leagueId: ID): EventTier @deprecated(reason: "Uses old LeagueBL::getTiersForEvents function")

    """List of all leagues that this event is attached to"""
    leagues: [League]

    """Relevant visible links for this event."""
    links: [ProfileNavFeature]

    """Markdown field for match rules/instructions"""
    matchRulesMarkdown: String

    """Title of event set by organizer"""
    name: String

    """The Networks on which the Videogame will be played"""
    networks: [Network]

    """The earliest upcoming phase"""
    nextUpcomingPhase: Phase

    """Gets the number of entrants in this event"""
    numEntrants: Int

    """The phases that belong to an event, paginated by filter criteria"""
    paginatedPhaseGroups(query: EventPhaseGroupPageQuery): PhaseGroupConnection

    """The phases that belong to an event, paginated by filter criteria"""
    paginatedPhases(query: EventPhasePageQuery): PhaseConnection

    """Paginated sets on this event"""
    paginatedSets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection

    """The phase groups that belong to an event."""
    phaseGroups: [PhaseGroup]

    """The phases that belong to an event."""
    phases(
        """Filter phases by state. If not specified will default to all phases"""
        state: ActivityState

        """Optionally only return results for this phase"""
        phaseId: ID
    ): [Phase]

    """The Platforms on which the Event's Videogame will be played"""
    platforms: [Platform]

    """TO settings for prizing"""
    prizingInfo: JSON

    """Shop products given out as prizes"""
    prizingProducts: [ShopProduct]
    publishing: JSON

    """When does registration closed for this Event?"""
    registrationDeadline: Timestamp

    """RegistrationOptions for this event."""
    registrationOptions(
        """
        Filter RegistrationOptions by fieldType. Omitting this argument will return all matched RegistrationOptions.
        """
        optionType: String
    ): [RegistrationOption]
    requests(
        """Requests in this direction"""
        direction: RequestDirection!
        query: EventRequestQuery
    ): ProfileRequestConnection

    """
    Whether or not Teams can register without having all required slots filled
    """
    requireFullTeam: Boolean

    """
    A list of possible restrictions that can be assigned to entities in this event
    """
    restrictions: [EntityRestriction]

    """Markdown field for event rules/instructions"""
    rulesMarkdown: String

    """The ruleset for this event"""
    ruleset: Ruleset

    """Id of the event ruleset"""
    rulesetId: Int

    """Settings pulled from the event ruleset, if one exists"""
    rulesetSettings: JSON @deprecated(reason: "Use ruleset")

    """true if seeding is published for this event"""
    seedingPublished: Boolean
    seeds(query: SeedPaginationQuery!): SeedConnection

    """Returns whether or not self-reporting is enabled for this event"""
    selfReportingEnabled: Boolean

    """Paginated sets for this Event"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection
    slug: String

    """Paginated list of standings"""
    standings(query: StandingPaginationQuery!): StandingConnection

    """When does this event start?"""
    startAt: Timestamp

    """The state of the Event."""
    state: ActivityState

    """Paginated stations on this event"""
    stations(query: StationFilter): StationsConnection

    """
    If applicable, what subleagues this event is part of. Optionally filter on parent league
    """
    subleagues(leagueId: ID): [Tournament]

    """Last date attendees are able to create teams for team events"""
    teamManagementDeadline: Timestamp

    """
    If this is a teams event, returns whether or not teams can set custom names
    """
    teamNameAllowed: Boolean

    """Team roster size requirements"""
    teamRosterSize: TeamRosterSize

    """
    Get a list of the top X entrants for this event. This supports batches of events
    """
    topEntrants(limit: Int!): [Entrant]

    """
    Get a list of the top X participants for this event. This supports batches of events
    """
    topParticipants(limit: Int!): [Participant]

    """
    Get a list of the top X standings for this event. This supports batches of events
    """
    topStandings(limit: Int!): [Standing]
    tournament: Tournament

    """
    The type of the event, whether an entrant will have one participant or multiple
    """
    type: Int

    """When the event was last modified (unix timestamp)"""
    updatedAt: Timestamp

    """URL for the Event. Optionally, build URL for resource under the Event"""
    url(
        """Event tab to build URL for"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """Whether the event uses the new EventSeeds for seeding"""
    useEventSeeds: Boolean

    """The entrant (if applicable) for a given user in this event"""
    userEntrant(
        """User to get entrant for. Defaults to currently logged in user."""
        userId: ID
    ): Entrant

    """
    Returns the logged in User's next match start time. This is the end-all-be-all source of truth. I promise.
    """
    userNextMatchTime: Timestamp

    """Return list of Sets that the current user is participating in"""
    userSets(
        """User to get sets for. Defaults to currently logged in user."""
        userId: ID
        sortType: SetSortType = MAGIC
        limit: Int = null
    ): [Set]

    """The current user's tasks for this event"""
    userTasks(allowFallbackTasks: Boolean = false, abortIfNotActive: Boolean = false, activeOnly: Boolean = true, excludeSystemIds: [ID] = null, limit: Int = null, shouldAggregate: Boolean = true, ctaMode: TaskCTAMode = STANDARD, viewFormat: TaskViewFormat = FULL_TASK): [Task]
    videogame: Videogame

    """Id of the videogame associated with this event"""
    videogameId: Int @deprecated(reason: "Use videogame")

    """The waves being used by the event"""
    waves(
        """Waves filtered by phaseId, returns all if not set."""
        phaseId: ID
    ): [Wave]

    """The entrant that won this event"""
    winnerEntrant: Entrant
}

"""Group of check in enabled phase groups for a given start time"""
type EventCheckInGroup {
    id: ID
    checkInFinalized: Boolean
    createdAt: Timestamp

    """The event the check in group is part of"""
    event: Event
    eventId: Int
    firebasePath: String
    firebasePrefix: String

    """Number of phase groups linked to this check in group"""
    numPhaseGroups: Int
    startAt: Timestamp
    updatedAt: Timestamp
}

type EventConnection {
    pageInfo: PageInfo
    nodes: [Event]
}

type EventDetails {
    events: [Event]
    total: Int
}

input EventEntrantPageQuery {
    page: Int
    perPage: Int
    sortBy: String
    filter: EventEntrantPageQueryFilter
}

input EventEntrantPageQueryFilter {
    name: String
}

input EventFilter {
    videogameId: [ID]
    type: [Int]
    published: Boolean
    id: ID
    ids: [ID]
    slug: String
    fantasyEventId: ID
    fantasyRosterHash: String
}

"""Information describing the status of a participant in an event"""
type EventInfo {
    """The entrantId of this entrant in this event."""
    entrantId: ID
    id: ID
    eventId: ID

    """Whether the event is unstarted, in-progress, or complete"""
    eventState: Int

    """The name of this entrant in this event."""
    name: String

    """Total number of entrants in this event."""
    numEntrants: Int

    """Did this participant pay for this event"""
    paid: Boolean
    placement: Int

    """The event slug."""
    slug: String
}

"""Name and Gamertag of the owner of an event in a league"""
type EventOwner {
    eventId: ID
    email: String
    gamerTag: String
    fullName: String
}

type EventOwnerConnection {
    pageInfo: PageInfo
    nodes: [EventOwner]
}

input EventOwnersQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
}

input EventPhaseGroupPageQuery {
    page: Int
    perPage: Int
    sortBy: String
    filter: EventPhaseGroupPageQueryFilter
}

input EventPhaseGroupPageQueryFilter {
    displayIdentifier: String

    """Array of phaseIds to include in search results"""
    phaseId: [ID] = null
    state: [Int]
}

input EventPhasePageQuery {
    page: Int
    perPage: Int
    sortBy: String
    filter: EventPhasePageQueryFilter
}

input EventPhasePageQueryFilter {
    name: String

    """Array of phaseIds to include in search results"""
    phaseIds: [ID] = null
    state: [Int]
}

"""Event Prizing"""
interface EventPrizing {
    id: ID
    prizingType: PrizingType
}

input EventRequestFilter {
    status: [RequestStatus]

    """Filter on the other type. i.e. requester/recipient"""
    entityType: String

    """Filter on the specific entity. Should also specify entityType"""
    entityId: ID
    location: LocationFilterType
    search: PaginationSearchType
}

input EventRequestQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: EventRequestFilter
}

"""An event seed in a event"""
type EventSeed {
    """The entrant for this event seed"""
    entrant: Entrant
    id: ID

    """Non-zero error code if an error occurred processing this seed"""
    errorCode: EventSeedErrorCode

    """If true, this seed should not be moved"""
    isLocked: Boolean

    """
    Indicates whether the phase seed is "in limbo". In other words, is the phase seed value currently trustworthy.
    """
    isPendingPhaseSeed: Boolean

    """True if this event seed has been removed from the event"""
    isRemoved: Boolean

    """The phase seed where this event seed starts"""
    originPhaseSeed: Seed

    """The seedNum for this event seed"""
    seedNum: Int
}

type EventSeedConnection {
    pageInfo: PageInfo
    nodes: [EventSeed]
}

"""The error code associated with an EventSeed"""
enum EventSeedErrorCode {
    NO_ERROR
    GROUP_SEED_NUM_UNAVAILABLE
    SEED_RANGE_FULL
    GROUP_SEED_NUM_OUTSIDE_RANGE
    GROUP_ALREADY_STARTED
}

input EventSeedPageQuery {
    page: Int
    perPage: Int
    filter: EventSeedPageQueryFilter
}

input EventSeedPageQueryFilter {
    name: String
    phaseIds: [ID]
}

"""An event-level Team, in the context of some competition"""
type EventTeam implements Team {
    id: ID
    acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
    adminUrl(tab: String): String
    allowedActions: [ActionSummary]
    bio: String

    """Does this team have a complete set of accepted members"""
    complete: Boolean

    """
    Uniquely identifying token for team. Same as the hashed part of the slug
    """
    discriminator: String
    entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
    entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
    event: Event @deprecated(reason: "Use the event field off the EventTeam type")
    eventId: Int @deprecated(reason: "Use event on EventTeam")
    globalTeam: GlobalTeam
    images(type: String): [Image]

    """
    Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
    """
    inviteLink: String
    isCurrentUserAdmin: Boolean

    """Are join requests allowed for the team?"""
    joinRequestsAllowed: Boolean
    league: League

    """
    For a centralized league team, get all event-level teams that still have team management open
    """
    leagueManagedEventTeams: [EventTeam]
    members(status: [TeamMemberStatus]): [TeamMember]
    name: String

    """
    Given an invite code, provide a user specific invite link. This is dependent on the user's registration status
    """
    registrationInviteLink(
        """Invite code for the event team"""
        inviteCode: String!

        """User ID to get invite link for. If null, defaults to the current user."""
        userId: ID = null
    ): String
    restrictions: [EntityRestriction]
    slug: String
    teamRosterSize: TeamRosterSize
    type: Int
    url(tab: String): String
    userMember(
        """User ID to get member for. If null, defaults to the current user."""
        userId: ID = null
    ): TeamMember
    verified: Boolean
    videogame: Videogame
}

type EventTeamConnection {
    pageInfo: PageInfo
    nodes: [EventTeam]
}

"""Used for league application tiers"""
type EventTier {
    id: ID

    """Additional criteria of tier."""
    additionalCriteria: Criteria
    description: String
    endAt: Timestamp

    """Name of this tier"""
    name: String

    """Point mapping group"""
    pointMappingGroup: PointMappingGroup
    startAt: Timestamp
}

"""Publishing settings for a hub's follower count"""
enum FollowerCountPublishingState {
    PRIVATE
    PUBLIC
}

"""A game represents a single game within a set."""
type Game {
    id: ID

    """Gets the users self reported stats for this game"""
    currentUserReportedStats: JSON

    """Score of entrant 1. For smash, this is equivalent to stocks remaining."""
    entrant1Score: Int

    """Score of entrant 2. For smash, this is equivalent to stocks remaining."""
    entrant2Score: Int

    """Aggregates self reported stats for all entrants in this game"""
    entrantReportedStats: JSON
    images(type: String): [Image]

    """The API Game that this was game was linked to if any"""
    linkedApiGame: JSON
    orderNum: Int

    """Selections for this game such as character, etc."""
    selections: [GameSelection]
    setId: Int @deprecated(reason: "We should add a set resolver if we need this")

    """The stage that this game was played on (if applicable)"""
    stage: Stage
    state: Int

    """The stats as computed by the UIMapping for this game."""
    stats: JSON
    uiMapping: UIMapping
    winnerId: Int
}

type GameConnection {
    pageInfo: PageInfo
    nodes: [Game]
}

input GameFilterType {
    """Only return Games for the given Set"""
    setId: ID

    """Only return Games for the given externalId"""
    externalId: String
}

"""A selection for this game. i.e. character/stage selection, etc"""
type GameSelection {
    """The entrant who this selection is for"""
    entrant: Entrant
    id: ID

    """If this is a character selection, returns the selected character."""
    character: Character
    entrantId: Int @deprecated(reason: "We should add an entrant resolver if we need this")
    orderNum: Int

    """
    The participant who this selection is for. This is only populated if there are
    selections for multiple participants of a single entrant
    """
    participant: Participant
    participantId: Int @deprecated(reason: "We should add a participant resolver if we need this")
    selectionType: GameSelectionType
    selectionValue: Int
}

"""The type of selection i.e. is it for a character or something else"""
enum GameSelectionType {
    """Character selection"""
    CHARACTER
}

"""Global Team"""
type GlobalTeam implements Team {
    id: ID
    acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
    adminUrl(tab: String): String
    bio: String

    """Does this team have a complete set of accepted members"""
    complete: Boolean

    """
    Uniquely identifying token for team. Same as the hashed part of the slug
    """
    discriminator: String
    entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
    entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
    event: Event @deprecated(reason: "Use the event field off the EventTeam type")
    eventId: Int @deprecated(reason: "Use event on EventTeam")
    eventTeams(query: TeamPaginationQuery): EventTeamConnection
    images(type: String): [Image]

    """
    Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
    """
    inviteLink: String
    isCurrentUserAdmin: Boolean

    """Are join requests allowed for the team?"""
    joinRequestsAllowed: Boolean

    """Leagues-level teams for leagues this team is competing in"""
    leagueTeams(query: TeamPaginationQuery): EventTeamConnection

    """Leagues this team is competing in"""
    leagues(query: TeamPaginationQuery): LeagueConnection
    members(status: [TeamMemberStatus]): [TeamMember]
    name: String
    slug: String

    """Tournaments this team is competing in"""
    tournaments(query: TeamTournamentsPaginationQuery): TournamentConnection
    type: Int
    url(tab: String): String
    userMember(
        """User ID to get member for. If null, defaults to the current user."""
        userId: ID = null
    ): TeamMember
    verified: Boolean
    videogame: Videogame
}

"""A profile that can contain other profiles within it"""
type Hub {
    adminUrl(tab: String): String
    id: ID
    bio: String
    city: String
    countryCode: String
    createdAt: Timestamp

    """Number of users following this hub"""
    followerCount: Int
    fullAddress: String
    images(type: String): [Image]
    isCurrentUserAdmin: Boolean
    lat: Float

    """Leagues linked to this hub"""
    leagues(query: HubTournamentsPaginationQuery): LeagueConnection
    lng: Float
    mapsPlaceId: String
    name: String
    postalCode: String
    primaryContact: String
    primaryContactType: String

    """Profile links attached to this hub"""
    profileLinks(tagName: [String]): [ProfileLink]

    """Linked profile tags created for this hub."""
    profileTags: [ProfileTag]
    publishingSettings: HubPublishingSettings

    """Get roles for this profile"""
    roles(page: Int, perPage: Int, includeUnconfirmed: Boolean): RoleConnection
    slug: String
    state: String

    """Tournaments linked to this hub"""
    tournaments(query: HubTournamentsPaginationQuery): TournamentConnection
    updatedAt: Timestamp
    url(tab: String): String
}

type HubConnection {
    pageInfo: PageInfo
    nodes: [Hub]
}

input HubPaginationFilter {
    search: PaginationSearchType
    isCurrentUserAdmin: Boolean
    includeSuperAdminHubs: Boolean
}

input HubPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: HubPaginationFilter
}

"""Publishing settings for a hub"""
type HubPublishingSettings {
    followerCount: FollowerCountPublishingState
    publishing: ProfilePublishingState
}

input HubTournamentsPaginationFilter {
    search: PaginationSearchType
    isFeatured: Boolean
    isCurrentUserAdmin: Boolean
    upcoming: Boolean
    videogameIds: [ID]
}

input HubTournamentsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: HubTournamentsPaginationFilter
}

"""An image"""
type Image {
    id: ID
    entity: String
    entityId: Int
    height: Float
    isOriginal: Boolean
    ratio: Float
    type: String
    uploadedBy: Int
    url: String
    width: Float
}

"""Content column for image"""
type ImageContentColumn implements ProfileContentColumn {
    caption: String
    colNum: Int
    contentType: String
    value: String
    valueLink: String
}

"""Reason for invalid short slug"""
enum InvalidSlugReason {
    """Short slug is numerically equal to zero"""
    EQUALS_ZERO

    """Short slug contains whitespace"""
    HAS_WHITESPACE

    """Short slug contains special characters"""
    HAS_SPECIAL_CHARS

    """
    Short slug contains hyphens or underscores not
    surrounded by alphanumeric characters
    """
    INVALID_DASHES

    """Short slug is empty"""
    EMPTY_SLUG
}

"""
The `JSON` scalar type represents JSON values as specified by
[ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""A league"""
type League {
    id: ID
    addrState: String

    """Build Tournament admin URL"""
    adminUrl(
        """Tournament admin tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String
    approved: Boolean

    """Attendee requirements for this tournament"""
    attendeeFieldConfig: JSON
    circuitPhaseGroup: CircuitPhaseGroup
    city: String
    contactEmail: String @deprecated(reason: "Use primaryContact fields")
    contactPhone: String @deprecated(reason: "Use primaryContact fields")
    contactTwitter: String @deprecated(reason: "Use primaryContact fields")
    countryCode: String

    """When the tournament was created (unix timestamp)"""
    createdAt: Timestamp
    currency: String
    customMarkdown: JSON @deprecated(reason: "No longer used")
    defaultTab: String
    details: String @deprecated(reason: "No longer used")
    emailDirections: String
    emailInstructions: String
    emailNote: String

    """When the tournament ends"""
    endAt: Timestamp
    entrantCount: Int
    eventCount: Int
    eventOwners(query: EventOwnersQuery): EventOwnerConnection

    """When does event registration close"""
    eventRegistrationClosesAt: Timestamp

    """
    Get all event level teams in this tournament for a given global team or player
    """
    eventTeams(globalTeamId: ID, playerId: ID): [EventTeam]

    """Paginated list of events in a league"""
    events(query: LeagueEventsQuery): EventConnection
    finalEvent: Event @deprecated(reason: "No longer used")

    """Hacked "progression" into this final event"""
    finalEventId: Int @deprecated(reason: "No longer used")
    generatedTabs: JSON
    gettingThere: String @deprecated(reason: "No longer used")

    """True if tournament has at least one offline event"""
    hasOfflineEvents: Boolean
    hasOnlineEvents: Boolean
    hashtag: String

    """Whether or not to hide the admins"""
    hideAdmins: Boolean
    images(type: String): [Image]
    includeQRCheckIn: Boolean
    includeQRCode: Boolean

    """Whether this league's events are all centralized by the admin"""
    isCentralized: Boolean

    """True if tournament has at least one online event"""
    isOnline: Boolean
    lat: Float
    links: TournamentLinks
    lng: Float
    mapsPlaceId: String
    minimumRequirements: JSON

    """The tournament name"""
    name: String

    """Get nomination event linked to this tournament"""
    nominationEvent: NominationEvent

    """Whether to send admin emails when a new person registers"""
    notifyAdmins: Boolean

    """Top X number of people in the standings who progress to final event"""
    numProgressingToFinalEvent: Int @deprecated(reason: "No longer used")
    numUniquePlayers: Int
    onsitePaymentMode: String
    ownerId: Int @deprecated(reason: "We should add an owner resolver if we need this")
    parentLeague: League
    paypalMode: String
    paypalUser: String
    postalCode: String
    primaryContact: String
    primaryContactType: String
    prizes: String @deprecated(reason: "No longer used")
    profileLinks(
        """Hub id to filter profile links on"""
        hubId: ID
    ): [ProfileLink]

    """Publishing settings for this tournament"""
    publishing: JSON
    qrCodeRedirect: String
    qrCodeRedirectType: String

    """The region of the tournament"""
    region: String @deprecated(reason: "No longer used")

    """When does registration for the tournament end"""
    registrationClosesAt: Timestamp

    """RegistrationOptions for this Tournament"""
    registrationOptions(
        """
        Filter RegistrationOptions by fieldType. Omit this argument to return all RegistrationOptions.
        """
        optionType: String
    ): [RegistrationOption]

    """
    The period of time before the start date to send a reminder email to registrants
    """
    reminderInterval: Int
    requests(
        """Requests in this direction"""
        direction: RequestDirection!
        query: LeagueRequestQuery
    ): ProfileRequestConnection
    rules: String

    """The short slug used to form the url"""
    shortSlug: String

    """Whether standings for this league should be visible"""
    showStandings: Boolean
    slug: String
    standing(
        """Entrant in an event connected to this league"""
        entrantId: ID!
    ): Standing
    standingGroup: StandingGroup

    """Paginated list of standings"""
    standings(query: StandingGroupStandingPageFilter): StandingConnection

    """When the tournament Starts"""
    startAt: Timestamp

    """
    State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
    """
    state: Int
    stripeMode: String
    stripeUserId: String
    subleagues: [League]

    """When is the team creation deadline"""
    teamCreationClosesAt: Timestamp
    tiers: [EventTier]

    """The timezone of the tournament"""
    timezone: String

    """The type of tournament from TournamentType"""
    tournamentType: Int

    """When the tournament was last modified (unix timestamp)"""
    updatedAt: Timestamp

    """Build Tournament URL"""
    url(
        """Tournament tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String
    userEligibleEvents: [UserEligibleEvents]
    venueAddress: String
    venueName: String
    videogames: [Videogame]
}

type LeagueConnection {
    pageInfo: PageInfo
    nodes: [League]
}

"""A schedule Item for leagues"""
type LeagueEventScheduleItem implements LegacyScheduleItem {
    """Call to action for a schedule league event"""
    cta: LeagueEventScheduleItemCallToAction
    date: Timestamp
    endAt: Timestamp
    event: Event

    """Max Points for an event"""
    maxPoints: Int
    name: String

    """Total Entrants for an event"""
    numEntrants: Int
    startAt: Timestamp
    state: ActivityState

    """Tier this event is part of"""
    tier: EventTier
    type: String
}

type LeagueEventScheduleItemCallToAction {
    text: String
    url: String
}

input LeagueEventsFilter {
    search: PaginationSearchType
    pointMappingGroupIds: [ID]
    tierIds: [ID]
    userId: ID
    upcoming: Boolean
    leagueEntrantId: ID
}

input LeagueEventsQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: LeagueEventsFilter
}

input LeaguePageFilter {
    id: ID
    ids: [ID]

    """ID of the user that owns this league."""
    ownerId: ID
    afterDate: Timestamp
    beforeDate: Timestamp
    computedUpdatedAt: Timestamp
    name: String
    isFeatured: Boolean
    hasBannerImages: Boolean
    activeShops: Boolean
    past: Boolean
    published: Boolean
    publiclySearchable: Boolean
    upcoming: Boolean
    videogameIds: [ID]
}

input LeagueQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: LeaguePageFilter
    sort: TournamentPaginationSort
}

input LeagueRequestFilter {
    status: [RequestStatus]

    """Filter on the other type. i.e. requester/recipient"""
    entityType: String

    """Filter on the specific entity. Should also specify entityType"""
    entityId: ID
    location: LocationFilterType
    search: PaginationSearchType
}

input LeagueRequestQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: LeagueRequestFilter
}

"""An interface for a type of schedule item"""
interface LegacyScheduleItem {
    name: String
    date: Timestamp
    startAt: Timestamp
    endAt: Timestamp
    state: ActivityState
    type: String
}

type LegacyScheduleItemConnection {
    pageInfo: PageInfo
    nodes: [LegacyScheduleItem]
}

"""Each individual item purchased during a transaction"""
type LineItem {
    id: ID
    cost: Float
    externalTypeId: Int
    name: String
    type: String
}

input LocationFilterType {
    countryCode: String
    state: String
    city: String
}

"""Content column for markdown"""
type MarkdownContentColumn implements ProfileContentColumn {
    colNum: Int
    contentType: String
    value: String
}

"""Match-level configuration"""
interface MatchConfig {
    id: ID
    bracketType: BracketType
}

"""
Different options available for verifying player-reported match results
"""
enum MatchConfigVerificationMethod {
    TWITCH
    STREAM_ME
    ANY
    MIXER
    YOUTUBE
}

"""Monetary prizing information"""
type MonetaryPrizing implements EventPrizing {
    id: ID
    amount: Float
    prizingType: PrizingType
}

input msaUserParams {
    idToken: String
    nonce: String
    email: String
}

type Mutation {
    acceptAccountInvite(userToken: String, userId: ID, regParams: regParams, updatePlayerParams: updatePlayerParams, msaUserParams: msaUserParams, contactInfoParams: contactInfoParams): User

    """Completes a User Confirmation."""
    confirmUserConfirmation(value: String!, email: String!): UserConfirmation

    """Create an xbox profile authorization given an MSA id token and nonce"""
    connectXboxAccount(idToken: String!, nonce: String!): ProfileAuthorization

    """Create a new oauth application"""
    createAuthClient(data: AuthClientUpdate!): AuthClient

    """Create a new User"""
    createUser(request: createUserRequest!): User

    """Delete an oauth application"""
    deleteAuthClient(id: ID!): Boolean

    """Regenerate an oauth application's secret"""
    regenerateAuthClientSecret(id: ID!): String

    """Reset the password of a user"""
    resetPassword(id: ID, token: String, confirmationId: ID, fields: resetPassword!): User

    """Start the process of making a payment."""
    startStripePayment(
        """The type of entity the user is paying for."""
        entityType: String!

        """The ID of the entity the user is paying for."""
        entityId: ID!

        """The amount of the payment in the currency's smallest unit."""
        amount: Int!

        """The three-letter ISO code of the currency of the payment."""
        currency: String!

        """Client session UUID used to uniquely identify checkout session"""
        sessionId: String!
    ): PaymentIntent

    """Update an oauth application"""
    updateAuthClient(id: ID!, data: AuthClientUpdate!): AuthClient

    """Update a profile request status"""
    updateRequestStatus(id: ID, status: RequestStatus!, hash: String): ProfileRequest

    """Upload image"""
    uploadPlayerImage(entityId: ID!, entityType: String!, imageType: String!, file: Upload!, userHash: String, tournamentId: ID): Player

    """Validate user shipping information"""
    validateShippingAddress(fields: ShippingAddress!, shopId: ID!): Address
}

"""A network through which a videogame can be played on a platform"""
type Network {
    id: ID
    connectName: String
    createdAt: Timestamp
    displayName: String
    updatedAt: Timestamp
}

type NetworkSelectionLeagueOfLegends {
    name: String
    server: String
}

"""A nomination event"""
type NominationEvent {
    id: ID
    endAt: Timestamp
    hashtag: String
    headerItems: [NominationHeaderItems]
    headerSettings: JSON
    images(type: String): [Image]
    name: String
    nominationFields: NominationFields
    nominationSettings: NominationSettings
    numToProgress: Int
    optInEndAt: Timestamp
    optInStartAt: Timestamp
    startAt: Timestamp
    tournamentId: ID
    twitterHandle: String
}

type NominationFields {
    hasAsk: Boolean
}

type NominationHeaderItems {
    title: String
    description: String
    displayOrder: Int
    hasOptInBtn: Boolean
}

type NominationSettings {
    type: String
}

"""A message associated with some entity"""
type Note {
    id: ID

    """Note contents"""
    content: String

    """Timestamp of note creation"""
    createdAt: String

    """User Id of user who created this note"""
    createdBy: ID

    """Name of the user who created this note"""
    createdByName: String

    """Entity id associated with this note"""
    entityId: ID

    """Entity type associated with this note"""
    entityType: String

    """Timestamp of note update"""
    updatedAt: String
}

"""[DEPRECATED] An action to do for a match"""
type OldSetTask {
    id: ID
    action: String
    active: Boolean
    activeAt: Timestamp
    dqAt: Timestamp
    entrantId: Int
    images(type: String): [Image]
    isCompleted: Boolean
    metadata: JSON
    taskOrder: Int
    type: Int
}

"""An entity option"""
type Option {
    createdAt: Timestamp
    id: ID
    enabled: Boolean
    entityId: Int
    entityType: String
    fieldType: String
    optionType: String
    required: Boolean
    updatedAt: Timestamp
    visible: Boolean
}

type PageInfo {
    total: Int
    totalPages: Int
    page: Int
    perPage: Int
    sortBy: String
    filter: JSON
}

"""Defines paging and filter for Games"""
input PaginatedGamesQuery {
    page: Int
    perPage: Int

    """Supported filter options to filter down Game results"""
    filter: GameFilterType!
}

input PaginationSearchType {
    fieldsToSearch: [String]
    searchString: String
}

"""A participant of a tournament; either a spectator or competitor"""
type Participant {
    id: ID

    """How this participant was added"""
    addedByInfo: ParticipantAddedByInfo

    """Admin only field - actions performed by admins"""
    adminActions: [AdminActions]

    """Admin only field - notes written by admins"""
    adminNotes: [Note]

    """How much money this participant owes"""
    balance: Float

    """If this participant was checked-in by admin"""
    checkedIn: Boolean

    """The time this participant was checked-in by admin"""
    checkedInAt: Timestamp

    """If this participant is claimed or not"""
    claimed: Boolean

    """Info for connected accounts to external services."""
    connectedAccounts: JSON

    """
    Contact Info selected during registration. Falls back to User.location and/or
    User.name if necessary. These fields are for admin use only. If you are not a
    tournament admin or the participant being queried, these fields will be null.
    Do not display this information publicly.
    """
    contactInfo: ContactInfo

    """Unix time when participant was made"""
    createdAt: Timestamp

    """Participant Decks for Card Games"""
    decks(
        """Filter Decks to show only decks for a given Event ID."""
        eventId: ID
    ): [Deck]

    """Visible display name for a participant. TO visible only."""
    displayName: String @deprecated(reason: "Use User.name")

    """
    Email of the user, only available to admins within 18 months of tournament completion for tournament administrators.
    """
    email: String

    """Entrants associated with this Participant, if applicable"""
    entrants: [Entrant]

    """Doubles partners for this participant, if applicable"""
    eventPartners: [ParticipantEventPartner]

    """The events this participant registered for within a Tournament."""
    events: [Event]

    """
    Admin only field describing paid status for each event. If not an admin, this field will be null
    """
    eventsInfo: [EventInfo]

    """The tag that was used when the participant registered, e.g. Mang0"""
    gamerTag: String
    images(type: String): [Image]

    """Phone number of participant"""
    phoneNumber: String
    player: Player

    """Id of the Player"""
    playerId: Int @deprecated(reason: "Use the player field to get the player ID instead. This field is no longer maintained.")

    """The prefix that the user set for this Tournament, e.g. C9"""
    prefix: String

    """Admin only field of which selections were made during registration."""
    registrationSelections: [RegistrationSelection]

    """Current state of this participant's tournament registration"""
    registrationState: TournamentRegistrationState

    """
    Tournament Admin viewable field. Shows details for required social connections
    """
    requiredConnections: [ProfileAuthorization]

    """Streams associated with this Participant's tournament registration"""
    streams: [Streams]
    teams: [Team]

    """The tournament this participant is associated to."""
    tournament: Tournament

    """Admin only field of any transactions made during registration"""
    transactions: [UserTransaction]

    """Url for public attendee page"""
    url: String

    """The user this participant is associated to."""
    user: User

    """Id of user associated with this participant"""
    userId: Int @deprecated(reason: "Use the user field to get the user ID properly. This field is no longer maintained.")

    """Venue pass selections for this participant."""
    venuePasses: [RegistrationSelection]

    """If this participant is verified as actually being in the tournament"""
    verified: Boolean
}

type ParticipantAddedByInfo {
    addedByType: String
    addedBy: User
}

type ParticipantConnection {
    pageInfo: PageInfo
    nodes: [Participant]
}

type ParticipantEventPartner {
    eventId: ID
    player: Player
}

input ParticipantPageFilter {
    id: ID
    ids: [ID]
    eventIds: [ID]
    search: PaginationSearchType
    gamerTag: String
    unpaid: Boolean
    incompleteTeam: Boolean
    missingDeck: Boolean
    checkedIn: Boolean
    notCheckedIn: Boolean
}

input ParticipantPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: ParticipantPageFilter
}

"""The information needed to make a payment."""
type PaymentIntent {
    """The ID of the payment intent at the third-party service."""
    externalId: String

    """A client secret, if needed to complete payment."""
    clientSecret: String
}

"""A phase in an event"""
type Phase {
    id: ID

    """Bracket-type specific Phase configuration"""
    bracketConfig: BracketConfig

    """The bracket type of this phase."""
    bracketType: BracketType

    """true if brackets are published for this phase"""
    bracketsPublished: Boolean

    """Whether the phase is eligible for check-in"""
    canEnableCheckIn: Boolean

    """Whether the phase has check-in enabled"""
    checkInEnabled: Boolean
    destPhaseLinks: [PhaseLink]

    """A list of destination phases from this current phase"""
    destPhases: [Phase]

    """The Event that this phase belongs to"""
    event: Event

    """Number of phase groups in this phase"""
    groupCount: Int
    groupTypeId: Int @deprecated(reason: "Use bracketType instead. Leaving this in for backwards compatibility.")

    """Whether or not a phase's group type is supported by event check-in."""
    groupTypeSupportedByEventCheckIn: Boolean

    """Whether or not a phase has progressions leading into it."""
    hasProgressionsIn: Boolean

    """Whether the phase is the default phase or not."""
    isDefault: Boolean

    """Is the phase an exhibition or not."""
    isExhibition: Boolean

    """Bracket-type specific Phase configuration for Matches"""
    matchConfig: MatchConfig

    """Name of phase e.g. Round 1 Pools"""
    name: String

    """The number of seeds this phase contains."""
    numSeeds: Int

    """OLD, NEED TO REMOVE. unpaginated phase groups under this phase"""
    oldPhaseGroups: [PhaseGroup]
    paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds' instead")

    """Percentage of matches completed for this phase"""
    percentComplete: Int

    """Phase groups under this phase, paginated"""
    phaseGroups(query: PhaseGroupPageQuery): PhaseGroupConnection

    """The relative order of this phase within an event"""
    phaseOrder: Int

    """The number of entrants progressing out of this phase per pool"""
    progressionData: [ProgressionData]

    """true if seeding is published for this phase"""
    seedingPublished: Boolean

    """Paginated seeds for this phase"""
    seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

    """Paginated sets for this Phase"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection

    """Default standings configuration for this Phase"""
    standingsConfig: StandingsConfig

    """
    Start time of phase computed based on event start time, waves, and phase groups
    """
    startAt: Timestamp

    """State of the phase"""
    state: ActivityState

    """Default stats configuration for this Phase"""
    statsConfig: StatsConfig

    """The current user's tasks for this phase"""
    userTasks: [Task]
    waves: [Wave]
}

type PhaseConnection {
    pageInfo: PageInfo
    nodes: [Phase]
}

"""A group within a phase"""
type PhaseGroup {
    """The bracket type of this group's phase."""
    bracketType: BracketType
    id: ID

    """URL for this phase groups's bracket."""
    bracketUrl: String
    checkInFinalizeAction: String
    checkInState: String

    """The sets of current round of a phase group"""
    currentRoundSets: [Set]

    """Unique identifier for this group within the context of its phase"""
    displayIdentifier: String

    """Event check in groups that the phase group is linked to"""
    eventCheckInGroup: EventCheckInGroup
    firebasePath: String

    """
    For the given phase group, this is the start time of the first round that occurs in the group.
    """
    firstRoundTime: Timestamp
    groupTypeId: Int

    """
    Matchmaking settings for this Phase Group. Should only be used in queries for
    Phase Groups that are known to be of the Matchmaking bracket type.
    """
    matchmakingSettings: JSON
    numRounds: Int

    """The number of seeds for a phase group."""
    numSeeds(checkInState: Int): Int
    oldSets(
        """Limit to Sets in the current round"""
        currentRoundOnly: Boolean = false
    ): [Set]
    paginatedSeeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection @deprecated(reason: "Please use 'seeds', which is now paginated")

    """Paginated sets on this phaseGroup"""
    paginatedSets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection @deprecated(reason: "Please use 'sets', which is now paginated")

    """Percentage of matches completed for this phase group"""
    percentComplete: Int

    """The phase associated with this phase group"""
    phase: Phase
    phaseId: Int @deprecated(reason: "Use phase")

    """The progressions out of this phase group"""
    progressionsOut: [Progression]
    raceConfig: JSON
    roundDisplayNames: JSON @deprecated(reason: "This is the wrong API for getting round titles. We need to put more work into the phaseGroup.rounds resolver to make it useful.")
    rounds: [Round]
    seedMap: JSON

    """Paginated seeds for this phase group"""
    seeds(query: SeedPaginationQuery!, eventId: ID): SeedConnection

    """Paginated sets on this phaseGroup"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection
    standingGroup: StandingGroup

    """Paginated list of standings"""
    standings(query: StandingGroupStandingPageFilter): StandingConnection

    """
    Unix time the group is scheduled to start. This info could also be on the wave instead.
    """
    startAt: Timestamp
    state: Int

    """Paginated stations on this phaseGroup"""
    stations(query: StationFilter): StationsConnection
    tiebreakOrder: JSON
    unpaginatedSeeds: [Seed]

    """
    URL for the phase group. Optionally, build URL for resource under the phase group
    """
    url(
        """Phase group (brackets) tab to build URL for"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """
    Gets seeds in this phaseGroup for a particular user. Normally this will only
    be 0 or 1 seed. There might be weird cases where someone has more seeds
    """
    userSeeds(
        """User ID to get sets for. If null, will default to current user."""
        userId: ID
    ): [Seed]

    """The current user's tasks for this phase group"""
    userTasks: [Task]
    wave: Wave
    waveId: Int @deprecated(reason: "Use wave")
}

type PhaseGroupConnection {
    pageInfo: PageInfo
    nodes: [PhaseGroup]
}

input PhaseGroupPageQuery {
    page: Int
    perPage: Int
    sortBy: String
    entrantIds: [ID]
    filter: PhaseGroupPageQueryFilter
}

input PhaseGroupPageQueryFilter {
    id: [ID]
    waveId: ID
}

"""A link which defines how players enter and progress from phases"""
type PhaseLink {
    id: ID

    """Seed number that the seed phase link ends at (inclusive)"""
    endSeed: Int

    """The mode for a seed phase link"""
    seedMode: String

    """Seed number that the seed phase link starts at (inclusive)"""
    startSeed: Int

    """The type of this phase link"""
    type: PhaseLinkType
}

"""The type of the phase link. Different types have different behaviors"""
enum PhaseLinkType {
    """Phase link for phase to phase progressions based on placement"""
    PLACEMENT

    """Used for amateur brackets to progress remainder players"""
    REMAINDER

    """Directly added entrants"""
    DIRECT

    """Event seed configuration definitions"""
    SEED
}

"""A schedule item for a phase"""
type PhaseScheduleItem implements LegacyScheduleItem {
    date: Timestamp
    endAt: Timestamp
    event: Event
    name: String
    phase: Phase
    startAt: Timestamp
    state: ActivityState
    type: String
}

"""A Platform that Videogames can be played on."""
type Platform {
    id: ID
    name: String

    """Networks that a videogame can be played on through this platform"""
    networks(videogameId: ID!): [Network]
}

"""A player"""
type Player {
    id: ID

    """Paginated, filterable list of ScheduleItems"""
    adminSchedule(query: PlayerScheduleQuery): ScheduleItemConnection @deprecated(reason: "Use User.tournaments")
    color: String

    """Player's country"""
    country: String @deprecated(reason: "Use User.location")
    gamerTag: String

    """Time of player's last gamertag change"""
    gamerTagChangedAt: Timestamp

    """Player's images"""
    images(type: String): [Image] @deprecated(reason: "Use User.images")

    """Whether this Player is an attendee for X tournament"""
    isInTournament(tournamentId: ID): Boolean

    """The name of this player based on the player's display settings"""
    name: String @deprecated(reason: "Use User.name")

    """Player's nameDisplay field"""
    nameDisplay: Int @deprecated(reason: "Use User.publishingSettings.name")

    """All participants for a player"""
    participants: [Participant]
    prefix: String

    """
    Get a specific ProfileAuthorization given a type (see AuthorizationType)
    """
    profileAuthorization(type: AuthorizationType!): ProfileAuthorization

    """Most recent active & published rankings"""
    rankings(limit: Int, videogameId: ID): [PlayerRank]

    """Recent sets for this player."""
    recentSets(
        """Use this to get H2H history between two players"""
        opponentId: ID
    ): [Set] @deprecated(reason: "Use the sets field instead.")

    """Recent standings"""
    recentStandings(
        videogameId: ID

        """
        Number of recent standings to fetch. Default value is 3. Maximum value is 20.
        """
        limit: Int
    ): [Standing]

    """Player's region"""
    region: String @deprecated(reason: "Region no longer exists")

    """Set history for this player."""
    sets(
        page: Int
        perPage: Int

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection

    """Player's state or province"""
    state: String @deprecated(reason: "Use User.location")

    """Player's twitch stream"""
    twitchStream: String @deprecated(reason: "Use User.profileAuthorizations")

    """Player's twitter handle"""
    twitterHandle: String @deprecated(reason: "Use User.profileAuthorizations")

    """Url for public user profile if player is linked to user"""
    url: String
    user: User
}

type PlayerConnection {
    pageInfo: PageInfo
    nodes: [Player]
}

input PlayerPageFilter {
    id: ID
    ids: [ID]
    name: String
    gamerTag: String
    searchField: String
    eventId: ID
    isUser: Boolean
    hideTest: Boolean
}

enum PlayerPaginationSort {
    id
}

input PlayerQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: PlayerPageFilter
    sort: PlayerPaginationSort
}

"""A player's ranks"""
type PlayerRank {
    id: ID
    allRanksInSeries: [PlayerRank]
    characterMains: [Character]
    iteration: RankingIteration
    player: Player
    previousRank: Int

    """The player's placement on the ranking"""
    rank: Int
    title: String
    videogameId: ID
}

type PlayerRankConnection {
    pageInfo: PageInfo
    nodes: [PlayerRank]
}

input PlayerRankPageFilter {
    id: ID
    ids: [ID]
}

input PlayerRankPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: PlayerRankPageFilter
}

input PlayerSchedulePaginationFilter {
    past: Boolean
    upcoming: Boolean
    search: PaginationSearchType
    videogameId: [ID]
    tournamentView: String
}

input PlayerScheduleQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: PlayerSchedulePaginationFilter
}

"""Defines the mapping of a field, or stat, to Standing Points"""
type PointMapping {
    id: ID
    config: JSON
    field: String

    """Range DSL string of point mapping's config"""
    rangeDSL: String
    type: String
}

"""A group of point mappings for a particular standing group"""
type PointMappingGroup {
    id: ID
    name: String

    """Number of events linked to this group"""
    numEvents: Int

    """Point mappings for this group"""
    pointMappings: [PointMapping]
}

"""Describes a source for points for a set"""
type PointSource {
    """The type of this source."""
    type: ID!

    """The field this source acts on"""
    field: String!

    """The config used to help calculate. Depends on type."""
    config: JSON
}

"""Type of prizing"""
enum PrizingType {
    PERCENTAGE
    FIXED_AMOUNT
    PRODUCT
    DEFAULT_PRIZING
}

"""Product prizing information"""
type ProductPrizing implements EventPrizing {
    id: ID
    claimed: Boolean
    claimedByUser: JSON
    prizingType: PrizingType
    shopProduct: ShopProduct
}

"""Normalized profile information."""
type Profile {
    id: ID
    slug: String
    lat: String
    lng: String
    venueAddress: String
    mapsPlaceId: String
    fullAddress: String
    primaryContact: String
    primaryContactType: String

    """Get people in this Profile, filtered by role"""
    people(
        """Which roles to show"""
        roles: [String]

        """Entity type of profile (defaults to tournament)"""
        profileType: String
    ): [User]

    """Get roles for this profile"""
    roles(page: Int, perPage: Int, includeUnconfirmed: Boolean): RoleConnection

    """Build Profile URL"""
    url(
        """tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """Tasks for the current user for this profile"""
    userTasks(activeOnly: Boolean = true, limit: Int = null): [Task]

    """Build Profile admin URL"""
    adminUrl(
        """Profile admin tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String
}

"""An OAuth ProfileAuthorization object"""
type ProfileAuthorization {
    id: ID

    """The access token for this auth"""
    accessToken: String

    """Unix timestamp for when the token expires"""
    expiresAt: Timestamp

    """The id given by the external service"""
    externalId: String

    """
    The username given by the external service (including discriminator if discord)
    """
    externalUsername: String
    isValid: Boolean

    """Service-specific metadata"""
    metadata: JSON
    stream: Stream

    """
    The name of the external service providing this auth i.e. "twitch"
    """
    type: AuthorizationType
    url: String
}

"""Used to build the content section columns of a profile"""
interface ProfileContentColumn {
    colNum: Int
    contentType: String
}

"""Used to build the content sections of a profile"""
type ProfileContentRow {
    id: ID
    contentColumns: [ProfileContentColumn]
    images(type: String): [Image]
    profileId: ID
    profileType: String
    rowNum: Int
}

"""Links an owner profile to the profile it owns."""
type ProfileLink {
    id: ID
    isFeatured: Boolean
    linkType: Int
    ownerId: Int
    ownerType: String
    profileId: Int

    """Profile tags attached to this profile link."""
    profileTags: [ProfileTag]
    profileType: String
}

type ProfileNav {
    profileId: ID
    topFeatures: [ProfileNavFeatureGroup]
    userFeatures: [ProfileNavFeatureGroup]
    eventDetails: EventDetails
    startAt: Int
    endAt: Int
    hasOnlineEvents: Boolean
    tournamentType: Int
    timezone: String
    city: String
    addrState: String
    countryCode: String
}

"""Used to build the frontend navbar for profile navigation"""
type ProfileNavFeature {
    activeState: Int
    badge: Int
    canEdit: Boolean
    count: Int
    events: [ProfileNavFeature]
    icon: String
    isPublished: Boolean
    startAt: Timestamp
    status: String
    subItems: [ProfileNavFeature]
    tab: String
    text: String
    type: String
    url: String
    viewMore: Boolean
}

"""Used to build the frontend navbar for profile navigation"""
type ProfileNavFeatureGroup {
    navFeatures: [ProfileNavFeature]
    title: String
}

"""Publishing state for the profile"""
enum ProfilePublishingState {
    PRIVATE
    LINK_ONLY
    PUBLIC
}

"""Request object for transactions between profile types"""
type ProfileRequest {
    id: ID

    """Link that the user must follow in order to accept the request"""
    acceptUrl: String

    """Connection entity associated with this request"""
    connection: RequestConnection

    """Unix time of when the request was created"""
    createdAt: Timestamp

    """Entity receiving this request"""
    recipient: RequestEntity
    requestData: JSON

    """User that created this request"""
    requestedByUser: User

    """Entity creating this request"""
    requester: RequestEntity

    """Profile type of object that initiated the request"""
    requesterType: String

    """Status of the request"""
    status: RequestStatus

    """Type of profile request"""
    type: Int

    """Unix time of when the request was updated"""
    updatedAt: Timestamp
}

type ProfileRequestConnection {
    pageInfo: PageInfo
    nodes: [ProfileRequest]
}

"""A tag owned by a profile. Currently only hubs can own tags"""
type ProfileTag {
    id: ID
    name: String
    ownerId: Int
    ownerType: String
}

"""A Profile Task"""
type ProfileTask {
    cta: JSON
    id: ID
    description: String
    featureId: ID
    isDismissible: Boolean
    meta: JSON
    prereqs: JSON
    profileId: ID
    profileType: String
    sortOrder: Int
    state: Int
    title: String
}

"""specification for a widget that can be placed on profile pages"""
type ProfileWidget {
    """All of the fields for the widget configuration form"""
    configGqlFields: [String]
    id: String
    defaultConfig: JSON
    description: String
    disableAdd: Boolean
    icon: String
    name: String
    supportedLayouts: [String]
    widgetComponentsNodeModule: String
}

"""layout of widgets on a profile page"""
type ProfileWidgetPageLayout {
    id: String
    config: JSON
    images(type: String): [Image]
    rows: JSON
    version: Int
}

"""
A connection between a placement in an origin phase group to a destination seed.
"""
type Progression {
    id: ID
    originOrder: Int
    originPhase: Phase
    originPhaseGroup: PhaseGroup
    originPlacement: Int
}

"""Data on phase progression, keyed on destination PhaseId"""
type ProgressionData {
    origin: Int
    numProgressing: Int
}

type Query {
    """Returns user address"""
    address(userId: ID!, type: String!): Address
    availableWidgets(profileType: String!): [ProfileWidget]

    """Returns a card"""
    card(externalId: ID): Card

    """Paginated, filterable list of cards"""
    cards(query: CardPaginationQuery!): CardConnection
    contentRows(profileType: String!, profileSlug: String, profileId: ID, page: String): [ProfileContentRow]

    """Returns the authenticated user"""
    currentUser: User

    """Returns a Deck"""
    deck(id: ID!): Deck

    """Returns a list of emailCategories"""
    emailCategories: [EmailCategory]

    """Returns a list of emailTypes"""
    emailTypes: [EmailType]

    """Returns an entrant given its id"""
    entrant(id: ID!): Entrant

    """Paginated, filterable list of entrants"""
    entrants(query: EntrantPaginationQuery!): EntrantConnection

    """Returns an event given its id or slug"""
    event(id: ID, slug: String): Event

    """Returns an event check in group given its id"""
    eventCheckInGroup(id: ID!): EventCheckInGroup

    """Returns a event seed given its id"""
    eventSeed(id: ID): EventSeed

    """Returns a Game given its id"""
    game(id: ID!): Game

    """Returns a paginated list of Games"""
    games(query: PaginatedGamesQuery): GameConnection

    """Get a hub by id or slug"""
    hub(id: ID, slug: String): Hub

    """Paginated, filterable list of hubs"""
    hubs(query: HubPaginationQuery): HubConnection

    """Returns an iteration given an id"""
    iteration(id: ID!): RankingIteration

    """Returns a league given its id or slug"""
    league(id: ID, slug: String): League

    """Paginated, filterable list of leagues"""
    leagues(query: LeagueQuery!): LeagueConnection

    """Get an application by id"""
    oauthApplication(id: ID!): AuthClient

    """List of scopes"""
    oauthScopes(ids: [ID]): [AuthScope]

    """Returns an array of EntityOptions"""
    options(entityType: String!): [Option]

    """Returns a participant given its id"""
    participant(id: ID!, isAdmin: Boolean): Participant

    """Returns a phase given its id"""
    phase(id: ID): Phase

    """Returns a phase group given its id"""
    phaseGroup(id: ID): PhaseGroup

    """Returns a player given an id"""
    player(id: ID!): Player

    """Returns a player rank given an id"""
    playerRank(id: ID!): PlayerRank

    """Paginated, filterable list of players"""
    players(query: PlayerQuery!): PlayerConnection
    profile(profileType: String!, profileSlug: String, profileId: ID): Profile

    """Deprecated"""
    profileAuthorization(id: ID, type: AuthorizationType, profileType: String, profileId: ID): ProfileAuthorization @deprecated(reason: "Use User.profileAuthorization")
    profileId(profileType: String!, profileSlug: String!): ID
    profileNav(profileType: String!, profileSlug: String, profileId: ID, isAdmin: Boolean, bustCache: Int): ProfileNav
    profileTasks(profileType: String!, profileId: ID!, systemIds: [ID], activeOnly: Boolean, showDismissed: Boolean, minPriority: Int): [Task]
    profileTranslations(profileType: String!, profileId: Int!): JSON
    profileWidgetPageLayout(profileType: String!, profileId: Int!, page: String!): ProfileWidgetPageLayout

    """Returns a list of regions, sorted by country"""
    regions: [Region]

    """Paginated, filterable list of ScheduleItems"""
    schedule(profileType: String!, profileId: ID, profileSlug: String, query: ScheduleQuery): LegacyScheduleItemConnection

    """Returns a phase seed given its id"""
    seed(id: ID): Seed

    """Returns an array of EntityOptionSelections"""
    selections(userId: ID!, entityType: String!): [Selection]

    """Returns a series given an id or slug"""
    series(id: ID, slug: String): RankingSeries

    """Returns a set given its id"""
    set(id: ID!): Set

    """Returns a set slot given its id"""
    setSlot(id: ID!): SetSlot

    """Returns a paginated list of Sets"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection

    """A shop entity"""
    shop(id: ID, slug: String): Shop

    """A shop level entity"""
    shopLevel(id: ID): ShopLevel

    """A shop product"""
    shopProduct(id: ID): ShopProduct

    """The availability state of a short slug"""
    slugAvailability(tournamentId: ID!, shortSlug: String): SlugAvailability

    """Returns a standing given a standingId"""
    standing(id: ID!): Standing

    """
    Returns a standing group given its container type and id, or its id directly
    """
    standingGroup(containerType: String, containerId: ID, id: ID): StandingGroup

    """Returns an station given its id"""
    station(id: ID!): Stations

    """Returns the CSV column definitions of the status update API call"""
    statusUpdateCsvConfig: CSVConfig

    """Returns an stream given its id"""
    stream(id: ID!): Streams

    """Returns all the stream queues for a given tournament"""
    streamQueue(tournamentId: ID!, includePlayerStreams: Boolean): [StreamQueue]

    """Returns a task for the current user"""
    task(id: ID!): Task @deprecated(reason: "Not yet implemented to fetch by ID. Use \"userTasks\" resolvers on specific domain objects instead for now")

    """Returns a team given its id"""
    team(id: ID, slug: String, inviteCode: String): Team

    """Paginated, filterable list of teams"""
    teams(query: TeamsPaginationQuery!): TeamConnection

    """Returns a team given its id"""
    test(id: ID!): Test

    """Returns the top games for the past 30 days by number of registrants"""
    topGames: [Videogame]
    topLevelNav(profileType: String!, profileSlug: String, profileId: ID, isAdmin: Boolean, bustCache: Int): TopLevelNav

    """Returns a tournament given its id or slug"""
    tournament(id: ID, slug: String): Tournament

    """Paginated, filterable list of tournaments"""
    tournaments(query: TournamentQuery!): TournamentConnection

    """Returns the CSV column definitions of the tracking update API call"""
    trackingUpdateCsvConfig: CSVConfig

    """Returns an unclaimed user given a user hash"""
    unclaimedUser(hash: String!, tournamentId: ID!): JSON

    """
    List of upcoming Events for the logged in User. Returns null if not logged in
    """
    upcomingEvents(
        """
        Maximum number of Events to return. Limit 100. This resource is not paginated, that is TBD if needed.
        """
        limit: Int

        """Filter upcoming Events by Tournament"""
        tournamentId: ID

        """
        Filter Events by in-person/online. Omit this argument to return BOTH in-person and online Events.
        """
        isOnline: Boolean

        """
        Filter by Events for which the User is an owner. Defaults to true, i.e.
        return Events user owns AND Events the user is participating in.
        """
        userIsOwner: Boolean = true
    ): [Event]

    """Returns a user given a user slug of the form user/abc123, or id"""
    user(id: ID, slug: String): User

    """Returns an array of EntityOptionValues"""
    values(entityType: String!): [Value]

    """Returns a videogame given its id"""
    videogame(id: ID, slug: String): Videogame

    """Returns paginated list of videogames matching the search criteria."""
    videogames(query: VideogameQuery!): VideogameConnection

    """Returns a list of votes for a user"""
    votes(userId: ID!): [Votes]
}

"""Race specific bracket configuration"""
type RaceBracketConfig implements BracketConfig {
    automaticEndTime: Timestamp
    id: ID
    automaticStartTime: Timestamp
    bracketType: BracketType
    goalTargetComparator: Comparator
    goalTargetValue: String
    limitMode: RaceLimitMode
    limitValue: Int
    raceType: RaceType
}

"""Enforces limits on the amount of allowable Race submissions"""
enum RaceLimitMode {
    BEST_ALL
    FIRST_ALL
    PLAYTIME
}

"""Race specific match configuration"""
type RaceMatchConfig implements MatchConfig {
    id: ID
    bracketType: BracketType

    """Can players report results?"""
    playerReportingEnabled: Boolean

    """Accepted methods of verification that players can use"""
    verificationMethods: [MatchConfigVerificationMethod]

    """Are players required to submit verification of their reported results?"""
    verificationRequired: Boolean
}

"""Race type"""
enum RaceType {
    GOALS
    TIMED
}

"""An iteration of a ranking series"""
type RankingIteration {
    id: ID
    description: String
    images(type: String): [Image]

    """Paginated, queryable list of player ranks"""
    playerRanks(query: PlayerRankPaginationQuery!): PlayerRankConnection
    publishedAt: Timestamp
    series: RankingSeries

    """URL for the ranking"""
    slug: String
    startAt: Timestamp
    title: String
}

"""A ranking series"""
type RankingSeries {
    id: ID
    images(type: String): [Image]
    iterations: [RankingIteration]
    locationDisplayName: String
    locationType: Int
    name: String
    slug: String
    url: String
    videogame: Videogame
    videogameId: Int
}

"""A region"""
type Region {
    id: ID
    continent: String
    country: String
    countryCode: String
    defaultTimezone: String
    isEU: Boolean
    region: String
    state: String
    stateLong: String
}

"""
Contains fields to be filled out during registration. The fields themselves are
RegistrationValues, and the actual selected value is a RegistrationSelection.
"""
type RegistrationOption {
    id: ID
    createdAt: Timestamp
    description: String
    fieldType: String
    isSubfield: Boolean
    name: String
    optionLimit: Int
    optionType: String
    required: Boolean
    updatedAt: Timestamp

    """List of RegistrationValues for this option"""
    values: [RegistrationValue]
    visible: Boolean
}

"""A selection made during registration"""
type RegistrationSelection {
    id: ID
    additional: RegistrationSelectionAdditional
    balance: Float

    """
    The type of the option for this selection. i.e. `event` or `additional`
    """
    optionType: String

    """The registration value associated with this selection"""
    regValue: RegistrationValue
    valueId: Int
}

union RegistrationSelectionAdditional = RegistrationSelectionAdditionalStandard | RegistrationSelectionAdditionalLeagueOfLegends

type RegistrationSelectionAdditionalLeagueOfLegends {
    value: NetworkSelectionLeagueOfLegends
    activeNetwork: String
    steamName: String
    token: String
}

type RegistrationSelectionAdditionalStandard {
    value: String
    steamName: String
    epicAccountId: String
    battlenetAccountId: String
    activeNetwork: String
    token: String
}

"""A possible choice for a registration option"""
type RegistrationValue {
    """If the RegistrationOption specifies a fee, this is the value"""
    fee: Float
    id: ID
    additional: JSON

    """If the RegistrationOption specifies an end time, this is the value"""
    endAt: Timestamp
    name: String

    """The ID of the RegistrationOption that this value is for"""
    optionId: ID

    """The type of domain object that this value references"""
    optionType: String

    """The ID of the domain object that this value references"""
    optionTypeId: ID

    """Contains Entity Type and Entity ID"""
    requires: [JSON]

    """If the RegistrationOption specifies a start time, this is the value"""
    startAt: Timestamp

    """How many of this value have been selected by participants?"""
    valueConsumed: Int

    """If the RegistrationOption specifies a limit, this is the value"""
    valueLimit: Int

    """
    TODO Not entirely sure what this means for a RegistrationValue, RegistrationOption also has a visible flag
    """
    visible: Boolean
}

input regParams {
    country: Int
    dob: String
    guardianEmail: String
    password: String
    tos: Boolean
    emailOptOut: Boolean
}

union RequestConnection = Participant | EventTier | Role | TeamMember | GlobalTeam

"""Incoming or Outgoing request"""
enum RequestDirection {
    INCOMING
    OUTGOING
}

union RequestEntity = Tournament | User | League | Event | Hub | GlobalTeam | EventTeam

"""Status of a request"""
enum RequestStatus {
    PENDING
    ACCEPTED
    REJECTED
    HIDDEN
}

type ResetAffectedData {
    affectedSetCount: Int
    affectedSets: [Set]
    affectedPhaseGroupCount: Int
}

input resetPassword {
    id: ID
    email: String
    currPassword: String
    newPassword: String
    confirmPassword: String
    captcha: String
}

"""The object imposing a restriction on other entities"""
union RestrictionContainer = Event

"""A role"""
type Role {
    id: ID
    entityId: Int

    """Name of the entity associated with this role"""
    entityName: String
    entityType: String
    roleName: String

    """Status of if this role was accepted/rejected/pending/etc"""
    status: RequestStatus

    """User associated with this role"""
    user: User
}

type RoleConnection {
    pageInfo: PageInfo
    nodes: [Role]
}

"""A round within a phase group"""
type Round {
    id: ID

    """
    If applicable, bestOf is the number of games
    one must win a majority out of to win a set in this round
    """
    bestOf: Int

    """Indicates this round's order in the phase group"""
    number: Int

    """The time that this round is scheduled to start at"""
    startAt: Timestamp
}

"""A ruleset for a videogame"""
type Ruleset {
    id: ID

    """Whether or not duplicate characters are allowed in decks"""
    allowCharacterDupes: Boolean

    """Maximum number of duplicates allowed for any given card in a deck"""
    cardDupeLimit: Int

    """Maximum number of cards allowed in a deck"""
    cardLimit: Int

    """Number of classes a player needs to select"""
    classSelectionCount: Int

    """Maximum number of decks allowed per player"""
    deckLimit: Int

    """Number of decks per class"""
    decksPerClass: Int

    """Description of the Ruleset"""
    description: String

    """Ruleset GameMode enumeration"""
    gameMode: Int

    """Whether or not the Ruleset is the default Ruleset of a Videogame"""
    isDefault: Boolean

    """Maximum number of cards allowed to overlap with other decks"""
    maxOverlap: Int

    """Minimum number of cards required to overlap with primary deck"""
    minOverlapWithPrimary: Int

    """Name of the Ruleset"""
    name: String

    """Whether a primary deck is required or not"""
    requirePrimaryDeck: Boolean

    """Additional Ruleset settings configuration"""
    settings: JSON

    """Ruleset type"""
    type: String

    """Id of the Videogame associated with this Ruleset"""
    videogameId: Int
}

"""Content column for schedule"""
type ScheduleContentColumn implements ProfileContentColumn {
    colNum: Int
    contentType: String
    filter: JSON
    label: String
}

"""An item that represents part of a schedule"""
type ScheduleItem {
    id: ID

    """The end date of this schedule item in the format Y-m-d"""
    endDate: String
    entity: ScheduleItemEntity
    name: String

    """The start date of this schedule item in the format Y-m-d"""
    startDate: String
    type: String
}

type ScheduleItemConnection {
    pageInfo: PageInfo
    nodes: [ScheduleItem]
}

"""The entity that this ScheduleItem is for"""
union ScheduleItemEntity = Tournament

input SchedulePaginationFilter {
    past: Boolean
    upcoming: Boolean
    dateRange: DateRangeFilterType
    search: PaginationSearchType
    location: LocationFilterType
    tierIds: [ID]
    eventIds: [ID]
    subleagueIds: [ID]
    videogameId: [ID]
    tournamentView: String
    subLeaderboardId: ID
}

enum SchedulePaginationSort {
    startAt
    endAt
}

input ScheduleQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: SchedulePaginationFilter
    sort: SchedulePaginationSort
}

"""
The score that led to this standing being awarded. The meaning of this field can
vary by standing type and is not used for some standing types.
"""
type Score {
    """
    The name of this score. e.g. "Kills" or "Stocks"
    """
    label: String

    """The raw score value"""
    value: Float

    """
    Like value, but formatted for race format events. Formatted according to the race config for the front end to use.
    """
    displayValue: String
}

"""A seed for an entrant"""
type Seed {
    id: ID

    """
    The state of the seed for event check-in. Conforms to CheckInState enum.
    """
    checkInState: SeedCheckInState

    """Map of Participant ID to checked in boolean"""
    checkedInParticipants: JSON
    entrant: Entrant
    entrantId: Int @deprecated(reason: "Use Entrant")

    """Set count and game count by this entrant"""
    gameAndSetCounts(phaseGroupId: ID!, eventId: ID): JSON
    groupSeedNum: Int
    isBye: Boolean

    """
    The entrant(s) that won the match that determined this entrant's elimination.
    """
    lostTo(phaseGroupId: ID!): JSON
    phase: Phase
    phaseGroup: PhaseGroup
    placeholderName: String
    placement: Int

    """The player(s) associated with this seed's entrant"""
    players: [Player]

    """Destination progression information for this seed"""
    progression: JSON
    progressionSeedId: Int

    """Source progression information"""
    progressionSource: Progression

    """Ladder entrant's current and highest stable rank recorded"""
    ranks(phaseGroupId: ID!): JSON
    seedNum: Int

    """
    Entrant's win/loss record for this standing. Scores do not include byes.
    """
    setRecordWithoutByes(phaseGroupId: ID!): JSON

    """Gets sets in this phaseGroup for this seed."""
    sets(
        """Filter which sets are returned by state."""
        stateFilter: SetStateFilter = {type: "exclude", states: []}
    ): [Set]
    standings(
        """
        The container of the standing groups to get standings for. If null, will return all standings.
        """
        containerType: String
    ): [Standing]

    """Tiebreak information for this seed"""
    tiebreakInfo(phaseGroupId: ID!): JSON
}

"""Action to take when check-in ends"""
enum SeedCheckInState {
    """Will not have to checkin"""
    NONE

    """Will have to checkin"""
    REQUIRED

    """Checked in but the deadline has not been reached yet"""
    CHECKED_IN

    """Checked in and the deadline has been reached"""
    MADE_IT

    """Not checked in and the deadline has passed"""
    MISSED_IT
    IGNORE
}

type SeedConnection {
    pageInfo: PageInfo
    nodes: [Seed]
}

input SeedPageFilter {
    id: ID
    entrantName: String
    checkInState: [Int]
    phaseGroupId: [ID]
    eventCheckInGroupId: ID
    phaseId: [ID]
    eventId: ID
    search: PaginationSearchType
}

input SeedPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: SeedPageFilter
}

"""An entity option selection"""
type Selection {
    id: ID
    createdAt: Timestamp

    """emailTypes for selections"""
    emailTypes: EmailType
    optionId: Int
    selectedByEntity: String
    selectedById: Int
    updatedAt: Timestamp
    valueId: Int

    """values for selections"""
    values: Value
}

"""A set"""
type Set {
    id: ID

    """A list of games that could be reported via API for this set"""
    apiGames: JSON

    """The possible inputs to the external API for fetching results"""
    apiReportingInputOptions: JSON
    bracketLink: String
    bracketName: String

    """Whether or not this set supports API reporting"""
    canApiReport: Boolean
    characters(mainEntrantId: ID): JSON

    """The time this set was marked as completed"""
    completedAt: Timestamp

    """The time this set was created"""
    createdAt: Timestamp
    currentUserSeedId: ID
    defaultStandingGroup: StandingGroup
    displayScore(mainEntrantId: ID): String
    entrant1Id: Int @deprecated(reason: "Deprecated field. Use slots instead.")
    entrant1Present: Boolean @deprecated(reason: "Do not use. Deprecated field.")
    entrant1Score: Int @deprecated(reason: "Should eventually exist on Standing, deprecate when it does")
    entrant2Id: Int @deprecated(reason: "Deprecated field. Use slots instead.")
    entrant2Present: Boolean @deprecated(reason: "Do not use. Deprecated field.")
    entrant2Score: Int @deprecated(reason: "Should eventually exist on Standing, deprecate when it does")

    """Retrieves a single slot in a set, given an entrantId"""
    entrantSlot(entrantId: ID): SetSlot

    """Event that this set belongs to."""
    event: Event

    """ID of the event this set belongs to"""
    eventId: Int @deprecated(reason: "Use event")

    """The number of set slots that have been occupied by an Entrant"""
    filledSlots: Int

    """Full round text of this set."""
    fullRoundText: String
    game(orderNum: Int!): Game
    games: [Game]

    """Whether this set contains a placeholder entrant"""
    hasPlaceholder: Boolean

    """
    The letters that describe a unique identifier within the pool. Eg. F, AT
    """
    identifier: String
    images(type: String): [Image]

    """Whether or not the authenticated user is participating in this Set."""
    isCurrentUserParticipating: Boolean

    """
    True if this set is allowed to be edited. If this is false, then there are downstream sets that have already been reported
    """
    isEditable: Boolean

    """
    Indicates whether this set is a preview set. Preview sets should support fewer
    actions because they do not exist in the database.
    """
    isPreview: Boolean

    """
    Indicates whether a set is reportable. This becomes true when all the slots are populated with a seed.
    """
    isReportable: Boolean
    isWinner(mainEntrantId: ID!): Boolean
    lPlacement: Int

    """
    The current user's tasks for this set. Uses the deprecated task system.
    """
    oldSetTasks: [OldSetTask] @deprecated(reason: "Being replaced with userTasks eventually.")
    opponentName(mainEntrantId: ID!): String

    """Paginated list of slots in a set"""
    paginatedSlots(query: SlotPageFilter, includeByes: Boolean = false): SetSlotConnection

    """Phase group that this Set belongs to."""
    phaseGroup: PhaseGroup
    phaseGroupId: Int @deprecated(reason: "Use phaseGroup")

    """
    Retrieves a single slot in a set, given a playerId. Defaults to current player
    """
    playerSlot(playerId: ID): SetSlot

    """Tasks for the player, on the set"""
    playerTasks: [ProfileTask]
    pointCalcConfig: [PointSource]

    """The sets that are affected from resetting this set"""
    resetAffectedData: ResetAffectedData
    resultText(mainEntrantId: ID!): String

    """The round number of the set. Negative numbers are losers bracket"""
    round: Int

    """
    Indicates whether the set is in best of or total games mode. This instructs
    which field is used to figure out how many games are in this set.
    """
    setGamesType: Int
    setLink: String

    """
    A possible spot in a set. Use this to get all entrants in a set. Use this for all bracket types (FFA, elimination, etc)
    """
    slots(includeByes: Boolean = false): [SetSlot]

    """
    The start time of the Set. If there is no startAt time on the Set, will pull it from phaseGroup rounds configuration.
    """
    startAt: Timestamp
    startedAt: Timestamp
    state: Int

    """Tournament event station for a set"""
    station: Stations
    stationId: Int @deprecated(reason: "Use station")

    """Station number of this set."""
    stationNumber: Int

    """The stats as computed by the UIMapping for this set."""
    stats(view: String = "setFinalization"): JSON

    """Tournament event stream for a set"""
    stream: Streams
    streamId: Int @deprecated(reason: "Use stream")

    """
    If setGamesType is in total games mode, this defined the number of games in the set.
    """
    totalGames: Int

    """The total possible number of slots available for Entrants"""
    totalSlots: Int

    """Tournament that this set belongs to."""
    tournament: Tournament
    uiMapping(view: String = "setFinalization"): UIMapping

    """
    Generally used in conjunction with firebase to see if set data should be updated
    """
    updatedAtMicro: Float

    """The current user's tasks for this set"""
    userTasks(allowFallbackTasks: Boolean = false, ctaMode: TaskCTAMode = STANDARD, viewFormat: TaskViewFormat = FULL_TASK, limit: Int = null, activeOnly: Boolean = true): [Task]

    """Url of a VOD for this set"""
    vodUrl: String
    wPlacement: Int
    winnerId: Int
}

type SetConnection {
    pageInfo: PageInfo
    nodes: [Set]
}

"""Filter Sets by geographical constraints."""
input SetFilterLocation {
    """Only return Sets in this state. Only applicable to US states"""
    state: String

    """
    Only return Sets in this country. Expects a valid two-letter country code
    """
    country: String
    distanceFrom: SetFilterLocationDistanceFrom
}

"""
Only return Sets that are a certain distance away from a specified point
"""
input SetFilterLocationDistanceFrom {
    """Point at which to perform distance calculation"""
    point: SetFilterLocationDistanceFromPoint

    """Distance from the point to include results in"""
    radius: String
}

input SetFilterLocationDistanceFromPoint {
    lat: Float
    lon: Float
}

input SetFilters {
    """Only return Sets for these Entrants"""
    entrantIds: [ID]

    """
    Only return Sets for this Entrant size. For example, to fetch 1v1 Sets only, filter by an entrantSize of 1
    """
    entrantSize: [Int]

    """Only return Sets that have an attached VOD"""
    hasVod: Boolean

    """
    Do not return empty Sets. For example, set this to true to filter out sets that are waiting for progressions.
    """
    hideEmpty: Boolean

    """Return sets that contain a bye"""
    showByes: Boolean

    """
    Only return Sets that are in an Online event. If omitted, Sets for both online and offline Events are returned
    """
    isEventOnline: Boolean

    """Only return Sets in certain geographical areas."""
    location: SetFilterLocation

    """Only return Sets for these Participants"""
    participantIds: [ID]

    """Only return Sets in these PhaseGroups"""
    phaseGroupIds: [ID]

    """Only return Sets in these Phases"""
    phaseIds: [ID]

    """Only return Sets in these Events"""
    eventIds: [ID]

    """Only return Sets in these Tournaments"""
    tournamentIds: [ID]

    """Only return Sets for these Players"""
    playerIds: [ID]

    """Only return Sets for these Rounds"""
    roundNumber: Int

    """Only returns Sets that are in these states"""
    state: [Int]

    """Only return Sets that are assigned to these Station IDs"""
    stationIds: [ID]

    """Only return Sets that are assigned to these Station numbers"""
    stationNumbers: [Int]

    """Only return sets created or updated since this timestamp"""
    updatedAfter: Timestamp
}

"""
A slot in a set where a seed currently or will eventually exist in order to participate in the set.
"""
type SetSlot {
    destinationSlot: SetSlot
    id: ID
    entrant: Entrant
    isFilled: Boolean

    """true if this slot progressed from the given setId"""
    isFromSet(setId: ID): Boolean
    originProgression: Progression
    originSet: Set

    """Pairs with prereqType, is the ID of the prereq."""
    prereqId: String

    """
    Given a set prereq type, defines the placement required in the origin set to end up in this slot.
    """
    prereqPlacement: Int

    """Describes where the entity in this slot comes from."""
    prereqType: String
    seed: Seed

    """
    Will be filled with a seedId once it is confirmed who will be participating in this slot.
    """
    seedId: Int @deprecated(reason: "Use seed")
    set: Set
    setId: ID @deprecated(reason: "Use set")

    """The index of the slot. Unique per set."""
    slotIndex: Int

    """
    The standing within this set for the seed currently assigned to this slot.
    """
    standing: Standing
}

type SetSlotConnection {
    pageInfo: PageInfo
    nodes: [SetSlot]
}

"""Different sort type configurations used when displaying multiple sets"""
enum SetSortType {
    """Sets will not be sorted."""
    NONE

    """
    Sets are sorted in the suggested order that they be called to be played. The order of completed sets is reversed.
    """
    CALL_ORDER

    """
    Sets are sorted by relevancy dependent on the state and progress of the event.
    """
    MAGIC

    """Sets are sorted in the order that they were started."""
    RECENT

    """Deprecated. This is equivalent to CALL_ORDER"""
    STANDARD

    """Sets sorted by round and identifier"""
    ROUND
}

input SetStateFilter {
    """Type of filter for state, supports values of "exclude" and "include"."""
    type: String!

    """List of states to exclude or include depending on the type setting."""
    states: [ActivityState]
}

input ShippingAddress {
    overrideAddress: Boolean
    name: String
    address: String
    address2: String
    city: String
    state: String
    zipcode: String
    country: String
}

"""A shop"""
type Shop {
    id: ID
    levels(query: ShopLevelsQuery): ShopLevelConnection
    messages(query: ShopOrderMessagesQuery): ShopOrderMessageConnection
    name: String
    slug: String
    url: String
}

"""A shop level"""
type ShopLevel {
    id: ID
    currAmount: Float
    description: String
    endAt: Timestamp
    goalAmount: Float
    images(type: String): [Image]
    name: String
    votingConfig: ShopVotingOptionConfig
    votingValues: [ShopVotingOptionValue]
}

type ShopLevelConnection {
    pageInfo: PageInfo
    nodes: [ShopLevel]
}

input ShopLevelsQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
}

"""The message and player info for a shop order"""
type ShopOrderMessage {
    id: ID

    """The player's gamertag. Returns null if anonymous message type"""
    gamertag: String

    """The order message"""
    message: String

    """The player's name. Returns null unless name & tag display is selected"""
    name: String

    """The player who left the comment"""
    player: Player

    """The total order amount"""
    total: Float
}

type ShopOrderMessageConnection {
    pageInfo: PageInfo
    nodes: [ShopOrderMessage]
}

input ShopOrderMessagesQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
}

"""Shop Product"""
type ShopProduct {
    id: ID
    description: String
    images(type: String): [Image]
    name: String
    shop: Shop
    type: Int
}

input ShopProductFilter {
    type: Int
    addressRequired: Boolean
    hasVariants: Boolean
}

"""A shop level voting option config"""
type ShopVotingOptionConfig {
    id: ID
    currAmount: Float
    description: String
    goalAmount: Float
    name: String
    numSelected: Int
    voteRatio: Float
}

"""A shop level voting option value"""
type ShopVotingOptionValue {
    id: ID
    name: String
    subname: String
}

input SlotPageFilter {
    page: Int
    perPage: Int
}

type SlugAvailability {
    id: ID
    slugState: SlugState
    invalidReason: InvalidSlugReason
    invalidMessage: String
    ownedTournament: Tournament
}

"""Slug availability with regards to ownership"""
enum SlugState {
    """Short slug is available"""
    AVAILABLE

    """Short Slug is unavailable"""
    UNAVAILABLE

    """Short slug can be overwritten by current user"""
    CAN_OVERWRITE

    """Short slug is the same"""
    NO_CHANGE

    """Short slug is unavailable"""
    UNAVAILABLE_UNPUBLISHED

    """Short slug is an invalid string"""
    INVALID
}

"""
Represents the name of the third-party social service (e.g Twitter) for OAuth
"""
enum SocialConnectionType {
    TWITTER
    TWITCH
    DISCORD
    MIXER
    XBOX
}

"""Video Stage"""
type Stage {
    id: ID

    """Abbreviation for the videogame"""
    abbrev: String

    """Stage name"""
    name: String

    """Videogame ID"""
    videogameId: Int
}

"""A standing indicates the placement of something within a container."""
type Standing {
    id: ID
    additionalDisplayColumns: [AdditionalColumn]

    """
    The containing entity that contextualizes this standing. Event standings, for
    example, represent an entrant's standing in the entire event vs. Set standings
    which is an entrant's standing in only a single set within an event.
    """
    container: StandingContainer
    entityId: Int @deprecated(reason: "We should add an entity resolver")
    entityType: String @deprecated(reason: "We should add an entity resolver")

    """
    If the entity this standing is assigned to can be resolved into an entrant, this will provide the entrant.
    """
    entrant: Entrant

    """The event this standing belongs to (if applicable)"""
    event: Event
    eventStandingPoints(entrantId: ID): StandingPoints
    isFinal: Boolean

    """
    The last two matches played by the entrant for this standing (if applicable)
    """
    lastMatches: JSON

    """
    Metadata that goes along with this standing. Can take on different forms based on standing group type and settings.
    """
    metadata: JSON
    numUniqueEvents: Int

    """
    What the standing is outOf, for example 1st out of 100. This is the total
    number of standings in the containing standing group.
    """
    outOf: Int
    placement: Int

    """The player(s) tied to this standing's entity"""
    player: Player
    points: [StandingPoints]
    pointsFromGame(setId: ID!, gameIndex: Int!): [StandingPoints]

    """The event level prizing this standing receives"""
    prizing: [EventPrizing]

    """The event level prize/winnings that this standing receives"""
    prizingAmount: Float @deprecated(reason: "Deprecated in favor of `prizing` field")

    """Entrant's win/loss record for this standing"""
    setRecordWithoutByes: JSON
    standing: Int @deprecated(reason: "The \"placement\" field is identical and will eventually replace \"standing\"")
    stats: StandingStats

    """The team tied to this standing's entity"""
    team: Team
    totalPoints: Float
}

type StandingConnection {
    pageInfo: PageInfo
    nodes: [Standing]
    filterLocalPlacementStart: Int
}

"""The containing entity that this standing is for"""
union StandingContainer = Tournament | Event | PhaseGroup | Set

"""
A standing group is a container for standings. The type field describes how the standings get calculated.
"""
type StandingGroup {
    id: ID
    config: JSON

    """Filters that can be applied to the paginated standings"""
    customFilters: [StandingGroupCustomFilterDefinition]
    isDefault: Boolean
    name: String

    """Paginated standings for this standing group"""
    paginatedStandings(query: StandingGroupStandingsPaginationQuery): StandingConnection

    """Point structures for a tier"""
    pointStructures: JSON
    standings: [Standing]

    """Standing for a given user"""
    userStanding(userId: ID): Standing
}

"""A filter that can be applied to the paginated standings"""
type StandingGroupCustomFilterDefinition {
    key: String
    displayName: String
    values: [StandingGroupCustomFilterValue]
}

"""A value of a filter that can be applied to the paginated standings"""
type StandingGroupCustomFilterValue {
    value: String
    displayName: String
}

input StandingGroupStandingPageFilter {
    page: Int
    perPage: Int
    sortBy: String
}

input StandingGroupStandingsCustomFilter {
    key: String
    value: String
}

input StandingGroupStandingsPageFilter {
    search: PaginationSearchType
    customFilters: [StandingGroupStandingsCustomFilter]
}

input StandingGroupStandingsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: StandingGroupStandingsPageFilter
}

input StandingPageFilter {
    id: ID
    ids: [ID]
    search: PaginationSearchType
}

input StandingPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: StandingPageFilter
}

"""Points values that can belong to a standing."""
type StandingPoints {
    id: ID
    description: String

    """The entrant these points belong to (if applicable)"""
    entrant: Entrant

    """The event these points belongs to (if applicable)"""
    event: Event
    internalNotes: String
    isManual: Boolean
    isVerified: Boolean
    quantity: Float
    sourceEntrant: Entrant
    sourceId: Int
    sourceType: String
    standing: Int

    """One off node for FFA display tables"""
    stats: JSON
}

type StandingPointsConnection {
    pageInfo: PageInfo
    nodes: [StandingPoints]
}

input StandingPointsPageFilter {
    id: ID
    isManual: Boolean
    search: PaginationSearchType
}

input StandingPointsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: StandingPointsPageFilter
}

"""Standings Configuration"""
type StandingsConfig {
    id: ID

    """The sorts, or tiebreakers, used to generate standings"""
    standingsSorts: [StandingsSort!]!
}

"""Defines a sort, or tiebreaker, for standings"""
type StandingsSort {
    id: ID
    orderNum: Int
    sortDirection: StandingsSortDirection
    sortType: StandingsSortType

    """StatDefinition of this StandingsSort"""
    statDefinition: StatDefinition
}

"""StandingsSort SortDirection, if required by its SortType"""
enum StandingsSortDirection {
    ASC
    DESC
}

"""StandingsSort SortType, or tiebreaker type"""
enum StandingsSortType {
    STAT
    COMPLETION_TIME
}

"""
Any stats related to this standing. This type is experimental and very likely to change in the future.
"""
type StandingStats {
    score: Score
}

"""
The method in which stats are aggregated upwards, ie. from the Game to Set level
"""
enum StatAggregationMethod {
    SUM
    MIN
    MAX
    AVG
}

"""Definition of a stat"""
type StatDefinition {
    id: ID
    abbreviation: String
    aggregationMethod: StatAggregationMethod
    description: String
    displayName: String
    orderNum: Int
    statKey: String
    valueType: StatValueType
}

input StationFilter {
    page: Int
    perPage: Int
}

"""Stations, such as a stream setup, at an event"""
type Stations {
    id: ID
    canAutoAssign: Boolean
    clusterId: Int @deprecated(reason: "We should add a cluster resolver if we want this")
    clusterNumber: String
    clusterPrefix: Int
    createdAt: Timestamp
    enabled: Boolean
    eventId: Int @deprecated(reason: "We should add an event resolver if we want this")
    followerCount: Int @deprecated(reason: "No longer used")
    identifier: Int
    isOnline: Boolean @deprecated(reason: "No longer used")
    numSetups: Int
    number: Int
    prefix: String
    queue: JSON
    queueDepth: Int
    state: Int

    """Tournament event stream for a set"""
    stream: Streams
    streamGame: String @deprecated(reason: "No longer used")
    streamId: Int @deprecated(reason: "Use stream")
    streamLogo: String @deprecated(reason: "No longer used")
    streamName: String @deprecated(reason: "No longer used")
    streamSource: Int @deprecated(reason: "No longer used")
    streamStatus: String @deprecated(reason: "No longer used")
    streamType: Int @deprecated(reason: "No longer used")
    streamTypeId: Int @deprecated(reason: "No longer used")
    tournamentId: Int @deprecated(reason: "Use tournament")
    updatedAt: Timestamp
}

type StationsConnection {
    pageInfo: PageInfo
    nodes: [Stations]
}

"""Stats Configuration"""
type StatsConfig {
    id: ID

    """Stat definitions"""
    statDefinitions: [StatDefinition]
}

"""The ValueType attributed to a StatDefinition"""
enum StatValueType {
    NUMBER
    DURATION
    TEXT
    BOOLEAN
}

"""A Stream object"""
type Stream {
    id: ID

    """The id given by the external stream service i.e. twitch channelId"""
    externalStreamId: String

    """Whether the stream is currently live. May be slightly delayed."""
    isOnline: Boolean

    """The name of the stream"""
    name: String

    """
    The name of the external service providing this auth i.e. "twitch"
    """
    type: StreamType
}

"""A Stream queue object"""
type StreamQueue {
    id: String

    """The sets on the stream"""
    sets: [Set]

    """The stream on the queue"""
    stream: Streams
}

"""Tournament Stream"""
type Streams {
    id: ID
    enabled: Boolean
    eventId: Int @deprecated(reason: "We should add an event resolver if we want this")
    followerCount: Int
    isOnline: Boolean
    numSetups: Int
    parentStreamId: Int
    removesTasks: Boolean
    streamGame: String
    streamId: String
    streamLogo: String
    streamName: String
    streamSource: StreamSource
    streamStatus: String
    streamType: Int
    streamTypeId: Int

    """URL for stream, defaults to EMBED type."""
    streamUrl(streamUrlType: StreamUrlType = EMBED): String
    tournamentId: Int @deprecated(reason: "We should add a tournament resolver if we want this")
}

"""Represents the source of a stream"""
enum StreamSource {
    """Stream is on twitch.tv channel"""
    TWITCH

    """Stream is on smashcast.tv channel"""
    HITBOX

    """Stream is on a stream.me channel"""
    STREAMME

    """Stream is on a mixer.com channel"""
    MIXER

    """Stream is on a youtube.com channel"""
    YOUTUBE
}

"""Represents the type of stream service"""
enum StreamType {
    TWITCH
    MIXER
    YOUTUBE
}

"""Represents an embed vs page."""
enum StreamUrlType {
    """Direct link to Embed: player.twitch.tv/?channel=..."""
    EMBED

    """
    Direct link to Page: twitch.tv/..."
    """
    PAGE
}

"""Represents a task for a user to complete for some entity"""
type Task {
    id: ID
    cta: JSON
    description: String
    dismissed: Boolean
    entity: TaskEntity
    entityId: ID @deprecated(reason: "Use entity")
    entityType: String @deprecated(reason: "Use entity")
    featureId: ID @deprecated(reason: "Use systemId now")
    meta: JSON
    player: Player @deprecated(reason: "Only works for sets. Use entity resolver instead to connect to a player")
    prereqs: JSON
    priority: Int
    sortOrder: Int
    state: Int
    systemId: Int
    timer: TaskTimer
    title: String
    type: String
}

"""Configure whether a task's CTA should be converted to a page link"""
enum TaskCTAMode {
    """Show the standard CTA for this task, if there is one."""
    STANDARD

    """
    Change the CTA of this task to be a link to the primary page for the entity.
    """
    PAGE_LINK
}

"""The entity that generated this task"""
union TaskEntity = Set | Event | PhaseGroup

"""Represents a timer or deadline for a task to be acted on."""
type TaskTimer {
    description: String
    endAt: Timestamp
    startAt: Timestamp
    title: String
}

"""DEPRECATED. Use TaskCTAMode instead"""
enum TaskViewFormat {
    """TODO"""
    FULL_TASK

    """TODO"""
    LINKS_ONLY
}

"""A team, either at the global level or within the context of an event"""
interface Team {
    id: ID
    acceptedMembers: [TeamMember] @deprecated(reason: "Use the new members resolver with just accepted status")
    adminUrl(tab: String): String
    bio: String

    """Does this team have a complete set of accepted members"""
    complete: Boolean

    """
    Uniquely identifying token for team. Same as the hashed part of the slug
    """
    discriminator: String
    entrant: Entrant @deprecated(reason: "Use the entrant field off the EventTeam type")
    entrantId: Int @deprecated(reason: "Use entrant on EventTeam")
    event: Event @deprecated(reason: "Use the event field off the EventTeam type")
    eventId: Int @deprecated(reason: "Use event on EventTeam")
    images(type: String): [Image]

    """
    Url that contains the inviteCode assigned to the team. This is the link team admins can share with new members.
    """
    inviteLink: String
    isCurrentUserAdmin: Boolean

    """Are join requests allowed for the team?"""
    joinRequestsAllowed: Boolean
    members(status: [TeamMemberStatus]): [TeamMember]
    name: String
    slug: String
    type: Int
    url(tab: String): String
    userMember(
        """User ID to get member for. If null, defaults to the current user."""
        userId: ID = null
    ): TeamMember
    verified: Boolean
    videogame: Videogame
}

"""A set of actions available for a team to take"""
type TeamActionSet implements ActionSet {
    id: ID
    actions(isAllowed: Boolean): [Action]
    addAlternate: Action
    addPlayer: Action
    removeAlternate: Action
    removePlayer: Action
}

type TeamConnection {
    pageInfo: PageInfo
    nodes: [Team]
}

"""A member of a team"""
type TeamMember {
    id: ID
    adminRole: Role
    createdAt: Timestamp
    inviteEmail: String
    isAlternate: Boolean
    isCaptain: Boolean
    isCoach: Boolean
    isStandIn: Boolean

    """The type of the team member"""
    memberType: TeamMemberType
    name: String
    participant: Participant

    """The participantId of the team member"""
    participantId: Int
    player: Player

    """The status of the team member"""
    status: TeamMemberStatus
    teamId: ID
}

"""Membership status of a team member"""
enum TeamMemberStatus {
    UNKNOWN
    ACCEPTED
    INVITED
    REQUEST
    ALUM
    HIATUS
    OPEN_SPOT
}

"""Membership type of a team member"""
enum TeamMemberType {
    PLAYER
    STAFF
}

input TeamPaginationFilter {
    globalTeamId: ID
    eventState: ActivityState
    eventId: ID
    eventIds: [ID]
    minEntrantCount: Int
    maxEntrantCount: Int
    search: PaginationSearchType
    type: Int
    tournamentId: ID
    memberStatus: [TeamMemberStatus]
    videogameId: [ID]
    isLeague: Boolean
    upcoming: Boolean
    past: Boolean
    rosterComplete: Boolean
    rosterIncomplete: Boolean
}

input TeamPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: TeamPaginationFilter
}

"""Team roster size requirements"""
type TeamRosterSize {
    maxAlternates: Int
    maxPlayers: Int
    minAlternates: Int
    minPlayers: Int
}

input TeamsPageFilter {
    id: ID
    eventId: ID
    tournamentId: ID
    eventIds: [ID]
    search: JSON
    type: TeamType
    playerId: ID
    videogameId: ID
    memberStatus: [TeamMemberStatus]
    rosterComplete: Boolean
    rosterIncomplete: Boolean
}

input TeamsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: TeamsPageFilter
}

input TeamTournamentsPaginationFilter {
    past: Boolean
    upcoming: Boolean
    search: PaginationSearchType
}

input TeamTournamentsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: TeamTournamentsPaginationFilter
}

"""The type of the team (event or global)"""
enum TeamType {
    UNKNOWN
    EVENT
    OVERALL
    EXACT
    GLOBAL
}

"""Test"""
type Test {
    """ID"""
    id: ID

    """Private Var"""
    privateVar: String

    """Semi-Private Var"""
    semiPrivateVar: String
}

"""
Represents a Unix Timestamp. Supports up to 53 bit int values,
as that is JavaScript's internal memory allocation for integer values.
"""
scalar Timestamp

input TopGameFilter {
    """
    Array of which # top game you want to filter on.e.g. [2, 3] will filter on the 2nd and 3rd top games
    """
    gameNums: [Int]
}

type TopLevelNav {
    profileId: ID
    color: String
    name: String
    images(type: String): [Image]
}

"""A tournament"""
type Tournament {
    id: ID
    addrState: String

    """Build Tournament admin URL"""
    adminUrl(
        """Tournament admin tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """Admin-only view of admins for this tournament"""
    admins(
        """Which roles to show"""
        roles: [String]
    ): [User]
    approved: Boolean

    """Attendee requirements for this tournament"""
    attendeeFieldConfig: JSON
    city: String
    contactEmail: String @deprecated(reason: "Use primaryContact fields")
    contactPhone: String @deprecated(reason: "Use primaryContact fields")
    contactTwitter: String @deprecated(reason: "Use primaryContact fields")
    countryCode: String

    """When the tournament was created (unix timestamp)"""
    createdAt: Timestamp
    currency: String
    customMarkdown: JSON @deprecated(reason: "No longer used")
    defaultTab: String
    details: String @deprecated(reason: "No longer used")
    emailDirections: String
    emailInstructions: String
    emailNote: String

    """When the tournament ends"""
    endAt: Timestamp

    """When does event registration close"""
    eventRegistrationClosesAt: Timestamp

    """
    Get all event level teams in this tournament for a given global team or player
    """
    eventTeams(globalTeamId: ID, playerId: ID): [EventTeam]
    events(limit: Int, filter: EventFilter): [Event]
    fullAddress: String
    gamesList: [Videogame]
    generatedTabs: JSON
    gettingThere: String @deprecated(reason: "No longer used")

    """True if tournament has at least one offline event"""
    hasOfflineEvents: Boolean
    hasOnlineEvents: Boolean
    hashtag: String

    """Whether or not to hide the admins"""
    hideAdmins: Boolean
    images(type: String): [Image]
    includeQRCheckIn: Boolean
    includeQRCode: Boolean
    isCentralized: Boolean

    """True if tournament has at least one online event"""
    isOnline: Boolean

    """Is tournament registration open"""
    isRegistrationOpen: Boolean
    lat: Float
    links: TournamentLinks
    lng: Float
    locationDisplayName: String
    mapsPlaceId: String

    """The tournament name"""
    name: String

    """Get nomination event linked to this tournament"""
    nominationEvent: NominationEvent

    """Whether to send admin emails when a new person registers"""
    notifyAdmins: Boolean

    """Number of attendees including spectators, if public"""
    numAttendees: Int
    onsitePaymentMode: String

    """The user who created the tournament"""
    owner: User
    ownerId: Int @deprecated(reason: "We should add an owner resolver if we need this")

    """Paginated, queryable list of participants"""
    participants(query: ParticipantPaginationQuery!, isAdmin: Boolean): ParticipantConnection
    paypalMode: String
    paypalUser: String
    permissionType: String
    postalCode: String
    primaryContact: String
    primaryContactType: String
    prizes: String @deprecated(reason: "No longer used")
    profileLinks(
        """Hub id to filter profile links on"""
        hubId: ID
    ): [ProfileLink]

    """Publishing settings for this tournament"""
    publishing: JSON
    qrCodeRedirect: String
    qrCodeRedirectType: String

    """The region of the tournament"""
    region: String @deprecated(reason: "No longer used")
    regionDisplayName: String

    """When does registration for the tournament end"""
    registrationClosesAt: Timestamp

    """RegistrationOptions for this Tournament"""
    registrationOptions(
        """
        Filter RegistrationOptions by fieldType. Omit this argument to return all RegistrationOptions.
        """
        optionType: String
    ): [RegistrationOption]

    """
    The period of time before the start date to send a reminder email to registrants
    """
    reminderInterval: Int
    requests(
        """Requests in this direction"""
        direction: RequestDirection!
        query: TournamentRequestQuery
    ): ProfileRequestConnection

    """Total user transaction revenue for this tournament"""
    revenue: Float
    rules: String

    """Returns a paginated list of Sets"""
    sets(
        page: Int
        perPage: Int

        """How to sort these sets"""
        sortType: SetSortType

        """Supported filter options to filter down set results."""
        filters: SetFilters
    ): SetConnection

    """Shop products attached to this tournament"""
    shopProducts(
        """Supported shop product filters"""
        filter: ShopProductFilter
    ): [ShopProduct]

    """The short slug used to form the url"""
    shortSlug: String

    """The slug used to form the url"""
    slug: String

    """When the tournament Starts"""
    startAt: Timestamp

    """
    State of the tournament, can be ActivityState::CREATED, ActivityState::ACTIVE, or ActivityState::COMPLETED
    """
    state: Int
    stations(page: Int, perPage: Int): StationsConnection
    streamQueue: [StreamQueue]
    streams: [Streams]
    stripeMode: String
    stripeUserId: String

    """When is the team creation deadline"""
    teamCreationClosesAt: Timestamp

    """Paginated, queryable list of teams"""
    teams(query: TeamPaginationQuery!): TeamConnection

    """The timezone of the tournament"""
    timezone: String

    """The type of tournament from TournamentType"""
    tournamentType: Int

    """When the tournament was last modified (unix timestamp)"""
    updatedAt: Timestamp

    """Build Tournament URL"""
    url(
        """Tournament tab to add to URL"""
        tab: String

        """
        Generate a relative URL. Defaults to true. Setting to false will generate an absolute URL
        """
        relative: Boolean = true
    ): String

    """
    Returns true if the supplied userId is an admin for the Tournament. Defaults
    to the currently logged in user if not provided.
    """
    userIsAdmin(userId: ID): Boolean

    """Get a given user's participant for this tournament"""
    userParticipant(
        """User ID to get participant for. If null, defaults to the current user."""
        userId: ID = null
    ): Participant

    """The current user's tasks for this tournament"""
    userTasks(activeOnly: Boolean = true, limit: Int = null): [Task]
    venueAddress: String
    venueName: String

    """List of all waves in this tournament"""
    waves: [Wave]
}

type TournamentConnection {
    pageInfo: PageInfo
    nodes: [Tournament]
}

type TournamentLinks {
    facebook: String
    discord: String
}

input TournamentLocationFilter {
    """Latitude, Longitude"""
    distanceFrom: String

    """e.g. 50mi"""
    distance: String
}

input TournamentPageFilter {
    id: ID
    ids: [ID]

    """ID of the user that owns this tournament."""
    ownerId: ID

    """
    If true, filter to only tournaments the currently authed user is an admin of
    """
    isCurrentUserAdmin: Boolean
    countryCode: String
    addrState: String
    location: TournamentLocationFilter
    afterDate: Timestamp
    beforeDate: Timestamp
    computedUpdatedAt: Timestamp
    name: String
    venueName: String
    isFeatured: Boolean
    isLeague: Boolean
    hasBannerImages: Boolean
    activeShops: Boolean
    regOpen: Boolean
    past: Boolean
    published: Boolean
    publiclySearchable: Boolean
    staffPicks: Boolean
    hasOnlineEvents: Boolean
    topGames: TopGameFilter
    upcoming: Boolean
    videogameIds: [ID]
    sortByScore: Boolean
}

enum TournamentPaginationSort {
    startAt
    endAt
    eventRegistrationClosesAt
    computedUpdatedAt
}

input TournamentQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: TournamentPageFilter
    sort: TournamentPaginationSort
}

"""State of a user's registration for a tournament"""
enum TournamentRegistrationState {
    """User is not registered for tournament"""
    UNREGISTERED

    """
    This participant was manually added by organizer and is not connected to a user account
    """
    ANONYMOUS

    """
    User was manually added to tournament by organizer and has not verified their participation
    """
    UNVERIFIED

    """User is registered for tournament and has verified their participation"""
    VERIFIED
}

input TournamentRequestFilter {
    status: [RequestStatus]

    """Filter on the other type. i.e. requester/recipient"""
    entityType: String

    """Filter on the specific entity. Should also specify entityType"""
    entityId: ID
    location: LocationFilterType
    search: PaginationSearchType
}

input TournamentRequestQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: TournamentRequestFilter
}

"""
Describes the means by which data is fetched from a user via a UI definition.
Also defines how the data returned from the UI maps to a schema.
"""
type UIMapping {
    id: ID

    """
    Data generated from the UI mapping and the scope it was fetched in. Use this to populate UI data.
    """
    data: JSON
    entries: [UIMappingEntry]
    videogameId: ID

    """
    The type of view described by this UI Mapping. Can be used to get specific UI Mapping types on the FE.
    """
    viewType: String
}

"""Defines a single component and where it maps to in the schema."""
type UIMappingEntry {
    component: Component

    """The key of this entry. Should be unique within its hierarchy."""
    key: String

    """The name of this entry. Can be used as a column name, for example."""
    name: String
}

input updatePlayerParams {
    name: String
    gamerTag: String
    prefix: String
    nameDisplay: Int
}

"""
The `Upload` special type represents a file to be uploaded in the same HTTP request as specified by
[graphql-multipart-request-spec](https://github.com/jaydenseric/graphql-multipart-request-spec).
"""
scalar Upload

"""A user"""
type User {
    id: ID
    address: JSON @deprecated(reason: "Use User.location")

    """Admin only fields that the user can toggle publishing on"""
    adminFields: UserAdminFields

    """OAuth Clients"""
    authClients: [AuthClient]

    """Access tokens for our api"""
    authTokens(applicationType: AuthTokenApplicationType!): [AuthToken]

    """Authorizations to external services (i.e. Twitch, Twitter)"""
    authorizations(types: [SocialConnectionType]): [ProfileAuthorization]
    bio: String

    """Public facing user birthday that respects user publishing settings"""
    birthday: String

    """Is this user allowed to set a fee for online events?"""
    canUseOnlineFee: Boolean
    cookiesAccepted: Boolean
    createdAt: Timestamp
    deleteAfter: Timestamp

    """
    Uniquely identifying token for user. Same as the hashed part of the slug
    """
    discriminator: String
    dob: String
    email: String

    """Formatted selections for email settings"""
    emailSelections: JSON

    """Events this user has competed in"""
    events(query: UserEventsPaginationQuery): EventConnection
    genderPronoun: String

    """Flag for if a user has already claimed a vote against an event today"""
    hasClaimedDailyVotes(tournamentId: ID): Boolean

    """Is user linked to an external provider (MSA)"""
    hasExternal: Boolean
    hasPermission(permission: String, entityType: String, entityId: ID): Boolean
    images(type: String): [Image]
    isFollowing: Boolean

    """Is user following a given profile"""
    isFollowingProfile(profileType: String, profileId: ID): Boolean
    language: String

    """Leagues this user has competed in"""
    leagues(query: UserLeaguesPaginationQuery): LeagueConnection

    """Public location info for this user"""
    location: Address

    """Public facing user location that respects user publishing settings"""
    locationDisplay: String

    """Public facing user name that respects user publishing settings"""
    name: String
    nameFirst: String @deprecated(reason: "Use User.adminFields.nameFirst")
    nameLast: String @deprecated(reason: "Use User.adminFields.nameLast")

    """player for user"""
    player: Player
    playerId: Int @deprecated(reason: "Use User.player")

    """
    Get a specific ProfileAuthorization given a type (see AuthorizationType)
    """
    profileAuthorization(type: AuthorizationType!): ProfileAuthorization
    publishingSettings: UserPublishingSettings
    registrationState: Int

    """List of reports against the user"""
    reports: [UserPunishment]

    """Active requested email address change, if any"""
    requestedEmail: String
    requests(
        """Requests in this direction"""
        direction: RequestDirection!
        query: UserRequestQuery
    ): ProfileRequestConnection
    slug: String
    teams(query: TeamPaginationQuery): TeamConnection

    """Tournaments this user is organizing or competing in"""
    tournaments(query: UserTournamentsPaginationQuery): TournamentConnection

    """Url for public user profile"""
    url: String

    """User votes for this user"""
    votes: [Votes]
}

"""Raw values for fields that the user can toggle publishing on"""
type UserAdminFields {
    birthday: String
    location: Address
    nameFirst: String
    nameLast: String

    """
    Get a specific ProfileAuthorization given a type (see AuthorizationType)
    """
    profileAuthorization(type: AuthorizationType!): ProfileAuthorization
}

"""Publishing settings for a user's birthday"""
enum UserBirthdayPublishingState {
    PRIVATE
    MONTH_DAY_ONLY
    PUBLIC
}

"""An action that requires user confirmation before being taken."""
type UserConfirmation {
    id: ID
    state: UserConfirmationState
    type: Int
    value: String
}

"""The state of a UserConfirmation"""
enum UserConfirmationState {
    """Confirmation has not been verified yet"""
    UNVERIFIED

    """Confirmation has been verified"""
    VERIFIED

    """Confirmation was canceled by user"""
    CANCELED

    """Confirmation has expired"""
    EXPIRED
}

"""
Events that the current user has permissions to submit in a league application
"""
type UserEligibleEvents {
    event: Event
    tier: EventTier
}

input UserEventsPaginationFilter {
    videogameId: [ID]
    eventType: Int
    minEntrantCount: Int
    maxEntrantCount: Int
    location: LocationFilterType
    search: PaginationSearchType
}

input UserEventsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: UserEventsPaginationFilter
}

input UserLeaguesPaginationFilter {
    videogameId: [ID]
    upcoming: Boolean
    past: Boolean
    search: PaginationSearchType
}

input UserLeaguesPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: UserLeaguesPaginationFilter
}

"""Publishing settings for a user's location"""
enum UserLocationPublishingState {
    PRIVATE
    COUNTRY_ONLY
    PUBLIC
}

"""Publishing settings for a user's name"""
enum UserNamePublishingState {
    PRIVATE
    FIRST_NAME_LAST_INITIAL
    PUBLIC
}

"""Publishing settings for a user's profile authorizations"""
type UserProfileAuthorizationPublishingSettings {
    discord: UserProfileAuthorizationPublishState
    displayFirst: AuthorizationType
    mixer: UserProfileAuthorizationPublishState
    twitch: UserProfileAuthorizationPublishState
    twitter: UserProfileAuthorizationPublishState
    xbox: UserProfileAuthorizationPublishState
}

"""Publishing state for a user's profile authorization"""
enum UserProfileAuthorizationPublishState {
    PRIVATE
    PUBLIC
}

"""Publishing settings for a user"""
type UserPublishingSettings {
    birthday: UserBirthdayPublishingState
    location: UserLocationPublishingState
    name: UserNamePublishingState
    profileAuthorizations: UserProfileAuthorizationPublishingSettings
    publishing: ProfilePublishingState
}

"""A ban or warning as a result of malicious actions"""
type UserPunishment {
    id: ID
    createdAt: Timestamp

    """Employee that created this punishment"""
    createdByUser: User
    expiresAt: Timestamp
    externalNotes: String
    internalNotes: String

    """User getting punished"""
    punishedUser: User
    type: Int
    updatedAt: Timestamp
}

input UserRequestFilter {
    status: [RequestStatus]

    """Filter on the other type. i.e. requester/recipient"""
    entityType: String

    """Filter on the specific entity. Should also specify entityType"""
    entityId: ID
    location: LocationFilterType
    search: PaginationSearchType
}

input UserRequestQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: UserRequestFilter
}

input UserTournamentsPaginationFilter {
    past: Boolean
    upcoming: Boolean
    search: PaginationSearchType
    videogameId: [ID]
    tournamentView: String
    excludeId: [ID]
}

input UserTournamentsPaginationQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: UserTournamentsPaginationFilter
}

"""Information about a payment made by a user"""
type UserTransaction {
    createdAt: Timestamp
    id: ID
    currency: String
    externalId: String
    externalType: String
    lineItems: [LineItem]
    livemode: Boolean

    """Total cost of all line items within the transaction"""
    totalCost: Float
    value: Float
}

"""An entity option value"""
type Value {
    createdAt: Timestamp
    enabled: Boolean
    id: ID
    entityId: Int
    entityType: String
    name: String
    optionId: Int
    updatedAt: Timestamp
    valueType: String
    valueTypeId: Int
    visible: Boolean
}

"""Content column for video"""
type VideoContentColumn implements ProfileContentColumn {
    caption: JSON
    colNum: Int
    contentType: String
    value: String
}

"""A videogame"""
type Videogame {
    id: ID
    approvedForOnlineFee: Boolean

    """All characters for this videogame"""
    characters: [Character]
    displayName: String

    """Tells whether this videogame has characters or not"""
    hasCharacters: Boolean
    hasDeckSupport: Boolean
    images(type: String): [Image]
    name: String

    """Platforms that this Videogame can be played on"""
    platforms: [Platform]
    satoriId: String
    slug: String

    """All stages for this videogame"""
    stages: [Stage]
    summary: String
}

type VideogameConnection {
    pageInfo: PageInfo
    nodes: [Videogame]
}

input VideogamePageFilter {
    id: [ID]
    name: String
    forUser: ID
}

input VideogameQuery {
    page: Int = 1

    """How many nodes to return for the page. Maximum value of 500"""
    perPage: Int = 25
    sortBy: String
    filter: VideogamePageFilter
}

"""A user's votes"""
type Votes {
    createdAt: Timestamp
    id: ID
    qty: Int

    """Vote selection"""
    selection: VoteSelection
    selectionId: Int
    sourceId: Int
    sourceType: Int

    """Tournament vote belongs to"""
    tournament: Tournament
    tournamentId: Int
    updatedAt: Timestamp
    userId: Int
    votingEventId: Int
}

"""A vote selection"""
type VoteSelection {
    id: ID
    entityId: Int
    entityType: String
    numVotes: Int

    """Player if entityType is player otherwise null"""
    player: Player
}

"""A wave in a tournament"""
type Wave {
    id: ID

    """The Wave Identifier"""
    identifier: String

    """Unix time the wave is scheduled to start."""
    startAt: Timestamp
}

